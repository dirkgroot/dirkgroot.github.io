[{"content":" Now that we have a server that can receive a request over TCP, handle it and send a response back, it looks like good time to start working on the client. We\u0026rsquo;ll also think about how we want to test our walking skeleton end-to-end. Progress Let\u0026rsquo;s grab the crude sequence diagram we drew in part 1 of this series and mark the parts we already covered in the two previous posts with a green color.\nAs you can see, our walking skeleton is almost an end-to-end skeleton. The only things left to do are to create a minimal client application, and write a main method for our server, so it can be started as a standalone program.\nDecisions Before we start coding, I\u0026rsquo;d like to make some decisions.\nHow will the player interact with the client? The specification doesn\u0026rsquo;t require any particular way of presenting the game to the player. As I\u0026rsquo;m the only stakeholder for this little project, and I happen to like ASCII-art based roguelike games, and I don\u0026rsquo;t feel like programming with Swing, or JavaFX or some other UI/graphics library, we\u0026rsquo;ll create a text-based user interface for the client. The player will control the his/her robot with the keyboard.\nThere, that was easy. Let\u0026rsquo;s think about testing.\nTesting end-to-end Up until now, we\u0026rsquo;ve created small tests, focused on small parts of the code. However, because we didn\u0026rsquo;t use test doubles1, every step up the call stack resulted in tests which covered more code. Now our goal with our walking skeleton is to get to a point where we can perform an end-to-end test of the tiny slice of functionality we created. That way we extend our test coverage to the deployment of our system and the integration of the various standalone components of the system2.\nWith an end-to-end test, rather than calling specific parts of the application code directly from our test code, we want to execute the test against the actual program. In our case, an end-to-end test scenario could look something like this:\nInstall and configure the server, and start it up. Install and configure the client, and start it up. Perform a small, well chosen, number of scenarios to make sure that all components of the system are working together nicely. If this were a \u0026ldquo;real\u0026rdquo; project, I would set up automated end-to-end tests as part of the walking skeleton, using test frameworks like Cypress or Robot Framework (in the case of web applications). For this little hobby project, I don\u0026rsquo;t mind having to execute end-to-end tests manually.\nI will, however, keep on using the Humble Object pattern to separate code that performs keyboard and screen I/O from code that can be automatically tested with JUnit tests.\nLet\u0026rsquo;s get to it Humble socket client The server has a humble SocketListener, which accepts incoming connections, passes requests to MessageReceiver and sends the response back to the client. Let\u0026rsquo;s mirror this in our client by creating a humble SocketClient.\nSo, I guess the test for our SocketClient should look something like our test for MessageReceiver. We need to set up a SocketListener for this, so our client module needs a test dependency on the server module. Let\u0026rsquo;s do that first.\ndependencies { testImplementation(kotlin(\u0026#34;test\u0026#34;)) testImplementation(\u0026#34;org.jetbrains.kotlin:kotlin-reflect:1.7.0\u0026#34;) testImplementation(\u0026#34;com.willowtreeapps.assertk:assertk:0.25\u0026#34;) testImplementation(project(\u0026#34;:server\u0026#34;)) } Now, let\u0026rsquo;s write a test.\n@Test fun `invoke launch command with JSON message`() { val socketListener = SocketListener(MessageReceiver(World())) val socketClient = SocketClient(socketListener.port) val result = socketClient.send(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(result).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } Make it compile by creating the SocketClient class with a stubbed send method.\nclass SocketClient(port: Int) { fun send(message: String): String { return \u0026#34;\u0026#34; } } Now the test compiles, and it fails: expected:\u0026lt;\u0026quot;[{\u0026quot;result\u0026quot;:\u0026quot;OK\u0026quot;}]\u0026quot;\u0026gt; but was:\u0026lt;\u0026quot;[]\u0026quot;\u0026gt;. Let\u0026rsquo;s make it pass. We\u0026rsquo;ll need to upgrade the constructor parameter port to a private property.\nclass SocketClient(private val port: Int) { fun send(message: String): String { return Socket(\u0026#34;127.0.0.1\u0026#34;, port).use { sendMessage(it, message) receiveResponse(it) } } private fun sendMessage(socket: Socket, message: String) { socket.getOutputStream().writer().apply { write(\u0026#34;$message\\n\u0026#34;) flush() } } private fun receiveResponse(socket: Socket) = socket.getInputStream().bufferedReader().readLine() } That\u0026rsquo;s quite a chunk of code to write to make one single test pass. Truth is, I\u0026rsquo;ve committed a horrible sin by copy/pasted and adjusted some code from the SocketListenerTest class we wrote in the previous post. This means we\u0026rsquo;ve now got some duplication to eliminate. Also, I don\u0026rsquo;t like the way we start a SocketListener in our test. Let\u0026rsquo;s address the last issue first.\nDecoupling To start the SocketListener from our test, we need to set up all the internals of the server.\nval socketListener = SocketListener(MessageReceiver(World())) We\u0026rsquo;ve introduced coupling3 between the client module\u0026rsquo;s test code and the internal structure of the server. This means that if we change the internal structure of the server, we must change this code as well. That\u0026rsquo;s not good. We prefer our tests to be sensitive to the behaviour of the system, not to the structure of the system4.\nLet\u0026rsquo;s refactor step by step. First, we\u0026rsquo;ll make a bit more explicit that the test needs to start the server, and needs to know what port the server is running on. We\u0026rsquo;ll introduce a port variable.\nval socketListener = SocketListener(MessageReceiver(World())) val port = socketListener.port val socketClient = SocketClient(port) val result = socketClient.send(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(result).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) Then inline the socketListener variable.\nval port = SocketListener(MessageReceiver(World())).port val socketClient = SocketClient(port) val result = socketClient.send(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(result).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) Now we can remove the knowledge about the server module\u0026rsquo;s internals from the test method by extracting a method.\n@Test fun `invoke launch command with JSON message`() { val port = startServerApplication() val socketClient = SocketClient(port) val result = socketClient.send(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(result).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } private fun startServerApplication() = SocketListener(MessageReceiver(World())).port Finally, let\u0026rsquo;s move the newly created startServerApplication function to the server module. I\u0026rsquo;ve put it in a new source file called ServerApplication.kt in the root package of the server module.\npackage nl.dirkgroot.robotworlds fun startServerApplication() = SocketListener(MessageReceiver(World())).port There, we\u0026rsquo;ve encapsulated all knowledge about the internal structure of the server module into the startServerApplication function. By moving said function to the server module, we completely decoupled the test code in the client module from the internal structure of the server module.\nDuplication Let\u0026rsquo;s look at the duplication we introduced. Look back at the SocketClient class earlier in this post, and compare it to what we have in SocketListenerTest.\n@Test fun `handles a command`() { val socketListener = SocketListener(MessageReceiver(World())) val port = socketListener.port assertTimeoutPreemptively(Duration.ofSeconds(1)) { Socket(\u0026#34;127.0.0.1\u0026#34;, port).use { socket -\u0026gt; sendLaunchCommand(socket) val response = receiveResponse(socket) assertThat(response).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } } } private fun sendLaunchCommand(socket: Socket) { socket.getOutputStream().writer().apply { write(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34; + \u0026#34;\\n\u0026#34;) flush() } } private fun receiveResponse(socket: Socket) = socket.getInputStream().bufferedReader().readLine() Now this is not a 100% duplicate, but I think it\u0026rsquo;s fairly obvious that both classes create a socket connection, send a message and receive a response. If only we could use SocketClient in SocketListenerTest\u0026hellip;\nSimplification I\u0026rsquo;m tempted to introduce a new module, named tcp-communication, move SocketClient to that module, and use this new module from the client and server module. But wait, why did we create separate modules for the server and the client? I don\u0026rsquo;t remember it being a very conscious decision. I guess I did it because I drew 2 separate containers in the container diagram. But now I think about it, having two separate containers just means that there are two separate processes. This doesn\u0026rsquo;t necessarily mean that they also need to be separate executables. We could just as well create one executable which can be started either in client or in server mode using a command-line switch.\nLet\u0026rsquo;s simplify the module structure, so we have just one module: game. I\u0026rsquo;ll do it step by step, like this:\nMove all code from client/src/main/kotlin to server/src/main/kotlin Move all code from client/src/test/kotlin to server/src/test/kotlin Remove the client module Rename the server to game Now there\u0026rsquo;s one thing I notice. In the client module I created a package called nl.dirkgroot.robotworlds.client, but in the server module I put everything in the nl.dirkgroot.robotworlds package. Let\u0026rsquo;s move the server code to nl.dirkgroot.robotworlds.server. All tests still pass, so everything went well.\nDeduplication Now that we have everything in one module, let\u0026rsquo;s see what we can do about the duplication we created. We\u0026rsquo;ll change the handles a command test in SocketListenerTest so it uses SocketClient.\n@Test fun `handles a command`() { val socketListener = SocketListener(MessageReceiver(World())) val port = socketListener.port assertTimeoutPreemptively(Duration.ofSeconds(1)) { val response = SocketClient(port).send(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(response).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } } The test passes, so we can delete the sendLaunchCommand and receiveResponse methods from SocketListenerTest, as those are not used anymore. Hmm, now there\u0026rsquo;s still duplication left. This test is basically the same as the test we wrote for SocketClient.\n@Test fun `invoke launch command with JSON message`() { val port = startServerApplication() val socketClient = SocketClient(port) val result = socketClient.send(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(result).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } The only differences are in how the socket listener is started and whether or not the test is timing out if no response is received for more than 1 second. One of these tests can be deleted, for sure. There\u0026rsquo;s no point in having two tests test exactly the same thing.\nI like the one with the timeout better, because it\u0026rsquo;s a little more robust than the one without, so let\u0026rsquo;s keep that one. This means that we can delete the SocketClientTest class entirely, because it only contains the test we\u0026rsquo;re going to delete.\nThis leaves us with a bit of an awkward situation, because now SocketListenerTest is responsible for testing both SocketClient and SocketListener. I don\u0026rsquo;t think this is necessarily a bad thing. After all, to me, the \u0026ldquo;unit\u0026rdquo; in unit testing is primarily a unit of behaviour - communication between client and server in this case - not a unit of structure (a particular class or function). The awkwardness is in the names of the test class and the tests.\nSo let\u0026rsquo;s just change the name of the test class to ClientServerCommunicationTest, and move it from the nl.dirkgroot.robotworlds.server package to nl.dirkgroot.robotworlds. Also, let\u0026rsquo;s change the initialisation part of the two tests to use the startServerApplication function, and rename handles a command to client can send a command to server over a TCP socket.\n@Test fun `listens on free TCP port when no port is given`() { val port = startServerApplication() Socket(\u0026#34;127.0.0.1\u0026#34;, port).use { assertThat(it.isConnected).isTrue() } } @Test fun `client can send a command to server over a TCP socket`() { val port = startServerApplication() assertTimeoutPreemptively(Duration.ofSeconds(1)) { val response = SocketClient(port).send(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(response).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } } I think I like where this is going. Let\u0026rsquo;s do a retrospective.\nRetrospective Horrible sin I committed a horrible sin by copy/pasting code, but in my defense, we were in the red stage of the red/green/refactor cycle. When we\u0026rsquo;re in the red stage, our goal is to get to green as fast as possible, by any means necessary. And that\u0026rsquo;s what we did. In the refactor stage, we cleaned up our mess.\nWorking like this creates a very clear distinction between getting code to work and designing our code. Furthermore, as you can see from this little project so far, most of the design work is done after we get some code to work. We did very little design up front, and we did it just to get an idea of where we\u0026rsquo;re heading.\nWhy does TDD work like this? Why do we refactor afterwards, instead of designing it \u0026ldquo;the right way\u0026rdquo; up front? In my experience, no matter how much design you do up front, refactoring afterwards will always be necessary to keep the code clean and well-factored. We just cannot foresee and account for every design issue we will face. When we\u0026rsquo;re writing the code, and when we\u0026rsquo;re mindful of what we\u0026rsquo;re creating, that\u0026rsquo;s when the most valuable design insights occur, because the code is right in front of us, and not in some fantasy in our minds.\nIntegration By eliminating the duplication we introduced, we ended up with a test class which tests the communication between the client and the server. We started out by testing the SocketListener by creating some stub client code, because that\u0026rsquo;s all we could do at that point. When we created the SocketClient class, we didn\u0026rsquo;t need the stub code anymore and replaced it with the actual client code. The result is what I would call an integration test.\nI\u0026rsquo;ve seen code bases where \u0026ldquo;integration tests\u0026rdquo; consisted of client code being tested by stubbing or mocking the server in some way, and of server code being tested by stubbing the client. To me, this is not integration testing. If we want to test whether two components integrate well, the best possible way to do that is by letting them actually \u0026ldquo;talk\u0026rdquo; to each other. As we\u0026rsquo;ve seen, this doesn\u0026rsquo;t just result in testing the actual integration between components. It also results in the elimination of duplication and all the risks that come with it.\nLet\u0026rsquo;s see if we can finish our walking skeleton next time, so we can start building some real end-to-end features. Thanks for reading, see you next time!\nOr mocks, as most people call them. In reality, a mock is only one of many kinds of test doubles. Take a look at the Test Double patterns on http://xunitpatterns.com if you want to know more about the terminology around test doubles.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThere\u0026rsquo;s a lot more to say about end-to-end testing and testing strategy in general, but that\u0026rsquo;s beyond the scope of this series.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWatch Kent Beck explain what coupling is.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAgain, watch Kent Beck: Test Desiderata 2/12 Tests Should be Structure-Insensitive.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://blog.dirkgroot.nl/posts/robot-worlds/03-client/","summary":"\u003csummary class=\"dg-summary\"\u003e\n    Now that we have a server that can receive a request over TCP, handle it and send a response back, it looks like good\ntime to start working on the client. We\u0026rsquo;ll also think about how we want to test our walking skeleton end-to-end.\n\u003c/summary\u003e","title":"Robot Worlds 3: Client"},{"content":" Our walking skeleton is no more than an undead skull at the moment. Some more bones need to be added to make it a fully fledged skeleton. Let\u0026rsquo;s see if we can set up communication between the client and the server. Recap So where are we? In the first post in this series, we established a general idea of what the architecture of the game looks like, and we started creating a walking skeleton. We started at the bottom of the call stack, and we\u0026rsquo;re working our way up, step by step.\nCommunication Today, I would like to start setting up communication between the client and the server over a TCP socket. For that, we\u0026rsquo;ll need to serialize and deserialize the messages to/from JSON, and send JSON over a TCP socket. Let\u0026rsquo;s see if we can invoke the launch command by sending it in JSON format to the server. But first\u0026hellip;\nReturning a result Looking at our launch command, I notice that it\u0026rsquo;s not returning a result.\nfun handleRequest(request: Request) { launchRobot() } According to the spec, every command must return a result, so let\u0026rsquo;s fix that first. Remember, for our walking skeleton, we return a very simple result:\n{ \u0026#34;result\u0026#34;: \u0026#34;OK\u0026#34; } So let\u0026rsquo;s first change our test.\n@Test fun `execute a launch command`() { val world = World() val result = world.handleRequest(Request(command = \u0026#34;launch\u0026#34;)) assertThat(world.robotCount).isEqualTo(1) assertThat(result).isEqualTo(CommandResult(result = \u0026#34;OK\u0026#34;)) } This doesn\u0026rsquo;t compile, because the CommandResult class does not exist yet. Let\u0026rsquo;s create that first.\nclass CommandResult(result: String) Good enough for now. Now our test fails: expected:\u0026lt;[nl.dirkgroot.robotworlds.CommandResult@750e2b97]\u0026gt; but was:\u0026lt;[kotlin.Unit]\u0026gt;. That looks ugly. Let\u0026rsquo;s make it prettier:\ndata class CommandResult(val result: String) Data classes in Kotlin are a convenient way to create classes that are meant to hold data. Among other things, the Kotlin compiler automatically provides data classes with equals, hashCode and toString. The generatedtoString method makes the error message look nicer.\nThere, that\u0026rsquo;s a lot better: expected:\u0026lt;[CommandResult(result=OK)]\u0026gt; but was:\u0026lt;[kotlin.Unit]\u0026gt;. Now, let\u0026rsquo;s make the test pass.\nfun handleRequest(request: Request): CommandResult { launchRobot() return CommandResult(result = \u0026#34;OK\u0026#34;) } (De)serialisation We\u0026rsquo;re still working on the game server. Now that we have a basic launch command working, let\u0026rsquo;s see what we need to add to the server so we can invoke it using a JSON message. Let\u0026rsquo;s ignore the TCP part for now and take a small step up the call stack. I think we\u0026rsquo;ll need a MessageReceiver which translates JSON messages to invocations of World::handleRequest.\nNo, let\u0026rsquo;s back off a little bit, and first make sure we can create a Request from JSON. If we have that in place, creating a MessageReceiver should be trivial.\n@Test fun `create a request from JSON`() { val request = Request.fromJSON(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(request).isEqualTo(Request(command = \u0026#34;launch\u0026#34;)) } I\u0026rsquo;ll let IntelliJ generate a stub for Request::fromJSON.\nclass Request(command: String) { companion object { fun fromJSON(json: String): Request { TODO(\u0026#34;Not yet implemented\u0026#34;) } } } Now our test fails, of course: An operation is not implemented: Not yet implemented. Let\u0026rsquo;s use Kotlin serialization to implement this.\nfun fromJSON(json: String): Request { return Json.decodeFromString(json) } Still fails: Serializer for class 'Request' is not found. Mark the class as @Serializable or provide the serializer explicitly. Request needs to be serializable.\n@Serializable class Request(command: String) Now we get a compiler error: \u0026ldquo;This class is not serializable automatically because it has primary constructor parameters that are not properties\u0026rdquo;. Okay, let\u0026rsquo;s make command a property.\n@Serializable class Request(val command: String) Now our test fails with an ugly message: expected:\u0026lt;...robotworlds.Request@[4de025bf]\u0026gt; but was:\u0026lt;...robotworlds.Request@[538613b3]\u0026gt;. I suspect this is because Request doesn\u0026rsquo;t have an equals implementation, so let\u0026rsquo;s upgrade it to a data class, like we did with CommandResult.\n@Serializable data class Request(val command: String) That was nice and easy. Now let\u0026rsquo;s move on to our MessageReceiver.\nLaunch with JSON First, we\u0026rsquo;ll try to invoke the launch command using a JSON message.\nclass MessageReceiverTest { @Test fun `invoke launch command with JSON message`() { val world = World() val messageReceiver = MessageReceiver(world) messageReceiver.receive(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(world.robotCount).isEqualTo(1) } } Doesn\u0026rsquo;t compile of course, so let\u0026rsquo;s create the MessageReceiver class, with a receive method.\nclass MessageReceiver(world: World) { fun receive(jsonMessage: String) { TODO(\u0026#34;Not yet implemented\u0026#34;) } } Implement it to make the test pass. For this, we\u0026rsquo;ll have to make the constructor parameter world a class member.\nclass MessageReceiver(private val world: World) { fun receive(jsonMessage: String) { val request = Request.fromJSON(jsonMessage) world.handleRequest(request) } } I\u0026rsquo;d like receive to return the result in JSON format, so let\u0026rsquo;s make sure we can serialize CommandResult to JSON.\nclass CommandResultTest { @Test fun `serialize to JSON`() { val json = CommandResult(result = \u0026#34;OK\u0026#34;).toJSON() assertThat(json).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;result\u0026#34;: \u0026#34;OK\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) } } Implement it in one fell swoop and use Kotlin serialization again.\n@Serializable data class CommandResult(val result: String) { fun toJSON(): String { return Json.encodeToString(this) } } The test fails: expected:\u0026lt;\u0026quot;{[ \u0026quot;result\u0026quot;: \u0026quot;OK\u0026quot; ]}\u0026quot;\u0026gt; but was:\u0026lt;\u0026quot;{[\u0026quot;result\u0026quot;:\u0026quot;OK\u0026quot;]}\u0026quot;\u0026gt;. Ah, apparently Json.encodeToString uses as few spaces as possible. Let\u0026rsquo;s adjust the test.\nassertThat(json).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) Done. Now let\u0026rsquo;s change MessageReceiver::receive to return a result in JSON format.\n@Test fun `invoke launch command with JSON message`() { val world = World() val messageReceiver = MessageReceiver(world) val result = messageReceiver.receive(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(world.robotCount).isEqualTo(1) assertThat(result).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } This fails with expected:\u0026lt;[\u0026quot;{\u0026quot;result\u0026quot;:\u0026quot;OK\u0026quot;}\u0026quot;]\u0026gt; but was:\u0026lt;[kotlin.Unit]\u0026gt;. We\u0026rsquo;ll use the CommandResult returned by World::handleRequest as our return value.\nfun receive(jsonMessage: String): String { val request = Request.fromJSON(jsonMessage) return world.handleRequest(request).toJSON() } A little refactoring In the previous article, we already had a suspicion that World would eventually need to be split up. Now that we have a MessageReceiver in place, it\u0026rsquo;s becoming obvious that World::handleRequest is out of place. Remember, its job is to take a request, execute the requested command, and return a result. Its responsibility is focused on request and response messages. I think the primary responsibility of World should be to handle game logic. It shouldn\u0026rsquo;t need to worry about messages, and MessageReceiver seems like a much better place for that. So let\u0026rsquo;s move handleRequest to MessageReceiver.\nI\u0026rsquo;ll start by copy-pasting handleRequest to MessageReceiver, change receive to use MessageReceiver::handleRequest instead of World::handleRequest, and make it compile.\nfun receive(jsonMessage: String): String { val request = Request.fromJSON(jsonMessage) return handleRequest(request).toJSON() } fun handleRequest(request: Request): CommandResult { world.launchRobot() return CommandResult(result = \u0026#34;OK\u0026#34;) } Tests still pass. Now we have two similar tests for the launch command, one in WorldTest and one in MessageReceiverTest. This is the one in WorldTest.\n@Test fun `execute a launch command`() { val world = World() val result = world.handleRequest(Request(command = \u0026#34;launch\u0026#34;)) assertThat(world.robotCount).isEqualTo(1) assertThat(result).isEqualTo(CommandResult(result = \u0026#34;OK\u0026#34;)) } And here\u0026rsquo;s the test in MessageReceiverTest.\n@Test fun `invoke launch command with JSON message`() { val world = World() val messageReceiver = MessageReceiver(world) val result = messageReceiver.receive(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) assertThat(world.robotCount).isEqualTo(1) assertThat(result).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } These tests are basically the same, except that the test for MessageReceiver is using JSON, and the test for World is using a Request object. Now, we could do two things: We could move the test in WorldTest to MessageReceiverTest and change it, so it uses MessageReceiver::handleRequest, or we could just delete the test in WorldTest. Let\u0026rsquo;s get rid of this duplication by deleting the test in WorldTest.\nTests still pass. Now that the duplicate test is gone, World::handleRequest is not used anywhere, so we can delete that as well. Finally, we can make MessageReceiver::handleRequest private, because it\u0026rsquo;s only used in MessageReceiver::receive.\nprivate fun handleRequest(request: Request): CommandResult { world.launchRobot() return CommandResult(result = \u0026#34;OK\u0026#34;) } Are you being served? Now, let\u0026rsquo;s start setting up a TCP socket listener.\nclass SocketListenerTest { @Test fun `listens on free TCP port when no port is given`() { val socketListener = SocketListener() val port = socketListener.port val socket = Socket(\u0026#34;127.0.0.1\u0026#34;, port) assertThat(socket.isConnected) .isTrue() socket.close() } } Create the SocketListener class.\nclass SocketListener { val port = 1 } And, as expected, our test fails: java.net.ConnectException: Connection refused. Making it pass is simple.\nclass SocketListener { private val serverSocket = ServerSocket(0) val port get() = serverSocket.localPort } We initialize the ServerSocket with port 0, so it will automatically choose an available port. If we pick a fixed port, there\u0026rsquo;s always a (small) risk that port is already taken, which could lead to flaky tests on the CI/CD pipeline. We don\u0026rsquo;t want flaky tests, so I\u0026rsquo;ll do whatever I can do to prevent that from happening.\nThe test code is a little verbose, so let\u0026rsquo;s make it more readable by using Kotlin\u0026rsquo;s handy dandy use extension.\n@Test fun `listens on free TCP port when no port is given`() { val socketListener = SocketListener() val port = socketListener.port Socket(\u0026#34;127.0.0.1\u0026#34;, port).use { assertThat(it.isConnected).isTrue() } } That\u0026rsquo;s a lot better. Now let\u0026rsquo;s see if we can make it handle a request.\n@Test fun `handles a command`() { val socketListener = SocketListener() val port = socketListener.port Socket(\u0026#34;127.0.0.1\u0026#34;, port).use { it.getOutputStream().writer().write(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) val response = it.getInputStream().bufferedReader().readLine() assertThat(response).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } } There\u0026rsquo;s a number of things that can be improved in this code, but let\u0026rsquo;s first see what happens. The SocketListener is not handling any messages, so the test waits indefinitely for a response. That\u0026rsquo;s not ideal. We want our test to fail, not to wait forever. Let\u0026rsquo;s fix that by using JUnit\u0026rsquo;s assertTimeoutPreemptively1.\n@Test fun `handles a command`() { val socketListener = SocketListener() val port: Int = socketListener.port assertTimeoutPreemptively(Duration.ofSeconds(1)) { Socket(\u0026#34;127.0.0.1\u0026#34;, port).use { it.getOutputStream().writer().write(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34;) val response = it.getInputStream().bufferedReader().readLine() assertThat(response).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } } } Now the test properly fails. The timeout of 1 second is my arbitrary choice. It\u0026rsquo;s always risky to have these kinds of tests, because they tend to be flaky. For now, I\u0026rsquo;m okay with this, because I\u0026rsquo;ll probably only be running these tests on my developer laptop, and I don\u0026rsquo;t think it will be flaky. If it is, I\u0026rsquo;ll just run the test again, or increase the timeout.\nLet\u0026rsquo;s see if we can make the test pass. To do that, we\u0026rsquo;ll need to start a separate thread which handles requests in the background. We\u0026rsquo;ll also need to hand our SocketListener a MessageReceiver, so it will be able to handle the messages it receives. Let\u0026rsquo;s first change the instantiation of SocketListener in our test.\nval socketListener = SocketListener(MessageReceiver(World())) Now we need to change the SocketListener constructor.\nclass SocketListener(private val messageReceiver: MessageReceiver) And finally we need to start the thread and handle the request.\ninit { Thread { serverSocket.accept().use { val request = it.getInputStream().bufferedReader().readLine() val response = messageReceiver.receive(request) it.getOutputStream().writer().write(\u0026#34;$response\\n\u0026#34;) } }.start() } This fails with a timeout. Ah, I forgot to send a newline after the request message. Let\u0026rsquo;s change that.\nit.getOutputStream().writer().write(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34; + \u0026#34;\\n\u0026#34;) It still fails. Apparently I\u0026rsquo;m doing something wrong, but it isn\u0026rsquo;t immediately obvious to me what that is. I see no other option than to use the debugger. Okay, so the SocketListener keeps blocking on val request = it.getInputStream().bufferedReader().readLine(). Do we need to flush the writer? Let\u0026rsquo;s try.\nit.getOutputStream().writer().apply { write(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34; + \u0026#34;\\n\u0026#34;) flush() } Te test still fails: expected:\u0026lt;\u0026quot;{\u0026quot;result\u0026quot;:\u0026quot;OK\u0026quot;}\u0026quot;\u0026gt; but was:\u0026lt;null\u0026gt;. It looks like we also need to flush in SocketListener.\nit.getOutputStream().writer().apply { write(\u0026#34;$response\\n\u0026#34;) flush() } Yes, that does the trick. Now, our code can be improved a bit, so let\u0026rsquo;s do that. First of all, let\u0026rsquo;s make our test code a bit more readable.\n@Test fun `handles a command`() { val socketListener = SocketListener(MessageReceiver(World())) val port = socketListener.port assertTimeoutPreemptively(Duration.ofSeconds(1)) { Socket(\u0026#34;127.0.0.1\u0026#34;, port).use { socket -\u0026gt; sendLaunchCommand(socket) val response = receiveResponse(socket) assertThat(response).isEqualTo(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;result\u0026#34;:\u0026#34;OK\u0026#34;}\u0026#34;\u0026#34;\u0026#34;) } } } private fun sendLaunchCommand(socket: Socket) { socket.getOutputStream().writer().apply { write(\u0026#34;\u0026#34;\u0026#34;{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; }\u0026#34;\u0026#34;\u0026#34; + \u0026#34;\\n\u0026#34;) flush() } } private fun receiveResponse(socket: Socket) = socket.getInputStream().bufferedReader().readLine() Now it\u0026rsquo;s a bit clearer what our test is actually doing. Let\u0026rsquo;s do something similar in SocketListener.\ninit { Thread { serverSocket.accept().use { val request = receiveRequest(it) val response = messageReceiver.receive(request) sendResponse(it, response) } }.start() } private fun receiveRequest(socket: Socket) = socket.getInputStream().bufferedReader().readLine() private fun sendResponse(socket: Socket, response: String) { socket.getOutputStream().writer().apply { write(\u0026#34;$response\\n\u0026#34;) flush() } } I think this is a good moment to call it a day, let\u0026rsquo;s do a little retrospective.\nRetro Everything went smooth, until we started messing with sockets. I don\u0026rsquo;t frequently work with sockets or input/output streams, so the need for flushing wasn\u0026rsquo;t immediately obvious to me. This is what typically happens when you\u0026rsquo;re working on the \u0026ldquo;edges\u0026rdquo; of the system. That\u0026rsquo;s where we need to deal with I/O, or databases, or queues, and often times non intuitive API\u0026rsquo;s.\nHumble object This is why I keep as much logic as possible separated from the code that has to deal with these kinds of API\u0026rsquo;s. That way, we maximize the amount of code that can easily be tested and understood. This is what\u0026rsquo;s called the Humble Object pattern. Our SocketListener is a humble object. Its only responsibilies are to accept connections, pass messages on to MessageReceiver and send the result back to the client.\nYAGNI Our SocketListener is far from done. It accepts one connection, handles one request and then stops. However, our goal is not to build a working feature, but to get just enough functionality working to allow us to start working on the first real feature. Our focus is not on functionality, but on setting up the general structure of the program and making sure it\u0026rsquo;s all testable.\nI\u0026rsquo;m relentlessly applying the YAGNI principle to get to our walking skeleton. I\u0026rsquo;m happily leaving out anything that is not strictly necessary for our goals. We\u0026rsquo;ll see if I\u0026rsquo;m going to regret doing that, but I think I won\u0026rsquo;t. Time will tell üòÉ.\nThanks for reading, and I\u0026rsquo;ll see you in the next one. You can find my source code on GitHub: https://github.com/dirkgroot/robot-worlds.\nThis assertion asserts that the lambda finishes before a timeout is exceeded. Read the the JavaDocs for more information.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://blog.dirkgroot.nl/posts/robot-worlds/02-communication/","summary":"\u003csummary class=\"dg-summary\"\u003e\n    Our walking skeleton is no more than an undead skull at the moment. Some more bones need to be added to make it a fully\nfledged skeleton. Let\u0026rsquo;s see if we can set up communication between the client and the server.\n\u003c/summary\u003e","title":"Robot Worlds 2: Communication"},{"content":" Let\u0026rsquo;s make a game! I have a big graveyard of unfinished hobby projects, so I have no idea how far I\u0026rsquo;ll get. But as long as learning ensues, I\u0026rsquo;m fine with that. Intro I created this blog site 6 months ago, so I guess it\u0026rsquo;s about time to actually start writing üôÑ. Here goes nothing!\nGeepaw Hill and Ron Jeffries both started a (v|b)log series on a fun programming exercise called Robot Worlds. From what I understand from these blogs, this exercise is part of an education offered by WeThinkCode_, which helps young South Africans train their digital skills.\nI really like doing these kinds of exercises, mainly because they are an excellent way of practicing my test-driven development skills, and a nice programming challenge in general. So let\u0026rsquo;s give it a go, shall we?\nYou can view the source code on GitHub: https://github.com/dirkgroot/robot-worlds.\nWhat is Robot Worlds? Robot Worlds is a multiplayer game in which the player controls a robot in a world full of obstacles, pits, and other robots. Robots can move around, scan their surroundings, shoot, and place mines. It consists of a client and a server, which communicate over a TCP socket connection, using messages in JSON format. Check out Hill\u0026rsquo;s GitHub repository for the specifications.\nThe container diagram1 below shows my current understanding of the architecture of the game.\nWalking skeleton Both Hill and Jeffries start out by building what\u0026rsquo;s called a \u0026ldquo;walking skeleton\u0026rdquo;, and I\u0026rsquo;ll be doing that as well. The term \u0026ldquo;walking skeleton\u0026rdquo; was coined by Alistair Cockburn, and the GOOS book describes it as follows:\nA ‚Äúwalking skeleton‚Äù is an implementation of the thinnest possible slice of real functionality that we can automatically build, deploy, and test end-to-end. It should include just enough of the automation, the major components, and communication mechanisms to allow us to start working on the first feature.\nHill and Jeffries have also given some valuable insights about what a walking skeleton is, and why it\u0026rsquo;s so useful. Check out their articles, they are really good!\nMy plan is to follow the definition of the GOOS book rather closely. This means I\u0026rsquo;ll create a client and a server application with just enough functionality to justify their existence and the need for communication between the client and the server.\nLet\u0026rsquo;s get started! Project setup First things first, let\u0026rsquo;s set up a basic project. I\u0026rsquo;ll be using Kotlin as my programming language, and IntelliJ IDEA as my IDE. I\u0026rsquo;ve set up a multi-module Gradle project with 2 modules to start with: client and server:\nrobot-worlds |... |- client | |- src/main/kotlin | |- src/test/kotlin | |- build.gradle.kts |... |- server | |- src/main/kotlin | |- src/test/kotlin | |- build.gradle.kts |... |- settings.gradle.kts Launch! So, what\u0026rsquo;s the \u0026ldquo;thinnest possible slice of real functionality\u0026rdquo; we could implement in our walking skeleton? Launching a robot into the world seems like a good candidate. To launch a robot into the world, the client must send a launch command to the server with some arguments, describing the robot it wants to launch. If all is well, the server then responds with a message containing an OK result and the current state of the robot (position, orientation, etc).\nI\u0026rsquo;d like to make this slice even thinner. Let\u0026rsquo;s start by implementing a very minimal version of the launch command and response. We\u0026rsquo;re leaving out the arguments from the command, and the state from the response. Furthermore, we\u0026rsquo;ll only implement the happy flow.\nThis is how the first version of the launch command will look:\n{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; } The response will look like this:\n{ \u0026#34;result\u0026#34;: \u0026#34;OK\u0026#34; } So, where to begin? Although this is indeed a very thin slice of real functionality, it\u0026rsquo;s still functionality that requires all major parts of the application to be in place. That way we can test it end-to-end. We need a client and a server, both need some kind of user interface, and the client needs to send commands to the server over a TCP socket.\nLet\u0026rsquo;s start from the bottom of the call stack, and step by step work our way upwards. What do I mean by this? This sequence diagram is a rough sketch of the call stack I currently have in mind.\nJust rotate your screen 90 degrees clockwise, and you\u0026rsquo;ll see what I mean. The top of the call stack is where everything starts: the Player. With every arrow we dive a level deeper into the call stack, until we arrive at World. So the bottom of the call stack in this case is World.\nWorld-class Let\u0026rsquo;s start nice and simple. First, write a test.\nclass WorldTest { @Test fun `no robots in a new world`() { val world = World() assertThat(world.robotCount).isZero() } } Making it pass is easy.\nclass World { val robotCount: Int = 0 } For our slice, we need a way to launch a robot into the world.\n@Test fun `launch a robot into the world`() { val world = World() world.launchRobot() assertThat(world.robotCount).isEqualTo(1) } We don\u0026rsquo;t have a launchRobot function yet, so make it compile first.\nclass World { val robotCount: Int = 0 fun launchRobot() { } } Our test fails, of course: expected:\u0026lt;[1]\u0026gt; but was:\u0026lt;[0]\u0026gt;. Let\u0026rsquo;s make it pass. We\u0026rsquo;ll make the robotCount a var instead of a val, to be able to update it\u0026rsquo;s value.\nvar robotCount: Int = 0 fun launchRobot() { robotCount++ } Now the robotCount property can be updated by everyone. Let\u0026rsquo;s make the setter private, so only World can update it.\nvar robotCount: Int = 0 private set Our tests still pass, so I guess the head of our walking skeleton is done üíÄ. It doesn\u0026rsquo;t have much of a brain yet, but with the amount of intelligence it currently has, I\u0026rsquo;d call it \u0026ldquo;undead\u0026rdquo;.\nRequest to launch Looking at the protocol specification, we can see that every interaction between client and server is initiated by the client. The communication style is request-response. The client requests the server to execute a command, and the server replies with a result.\nSo, if we move one step up the call stack from World::launch, what would we need? I think it\u0026rsquo;s a function that takes a request and executes the requested command. Let\u0026rsquo;s implement this without worrying about (de)serializing from/to JSON yet. We\u0026rsquo;ll start by adding a test to WorldTest.\n@Test fun `execute a launch command`() { val world = World() world.handleRequest(Request(command = \u0026#34;launch\u0026#34;)) assertThat(world.robotCount).isEqualTo(1) } This doesn\u0026rsquo;t compile, because we don\u0026rsquo;t have a Request class, and World doesn\u0026rsquo;t have a handleRequest method. Let\u0026rsquo;s start by letting IntelliJ generate a Request class for us (I\u0026rsquo;m lazy).\nclass Request(command: String) Easy. Now, IntelliJ can generate the World::handleRequest method as well.\nfun handleRequest(request: Request) { } Now our test compiles, but it fails: expected:\u0026lt;[1]\u0026gt; but was:\u0026lt;[0]\u0026gt;, so let\u0026rsquo;s make it pass.\nfun handleRequest(request: Request) { launchRobot() } Yep, that\u0026rsquo;s all we need for now.\nReally? Remember the description from the GOOS book earlier in this post. Our goal here is not to build an entire feature:\n[\u0026hellip;] It should include just enough of the automation, the major components, and communication mechanisms to allow us to start working on the first feature.\nWe just want to get all the stuff in place that we need to build and test our first feature end-to-end. In a real-world project this would typically include setting up build scripts, CI/CD, deployment to DTAP environments, etc. By doing this first, we benefit from having all this from the very start. Immediately, we have everything in place to make sure that every bit of functionality we add is well-tested, well-factored and potentially shippable.\nSummary We started out by drawing a little architecture diagram to get an overview of the major parts of the game that we\u0026rsquo;re building. Later on, the sequence diagram helped us choose a starting point for writing some actual code. I feel like that was just enough \u0026ldquo;design up front\u0026rdquo; to get me started.\nWe got some of the boring project set up stuff out of the way. The project is set up and a tiny part of a tiny slice of functionality is in place. The Worldclass will almost certainly be split up into the actual game logic and one or more other classes which handle requests from the client. We could have chosen to do that right now, but we can also do it later. I don\u0026rsquo;t think it\u0026rsquo;s really important right now.\nFor now, our goal is to put the major components in place, and World is one of them. The next steps up the call stack will most likely be the TCP socket connection and (de)serialization of messages.\nSo there it is, 6 months after setting it up, this blog has finally officially been kicked off. I hope you enjoyed my first post. I certainly enjoyed writing it. Stay tuned for the next one!\nThe container diagram is one of the 4 core diagrams of the C4 model for visualising software architecture.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://blog.dirkgroot.nl/posts/robot-worlds/01-walking-skeleton/","summary":"\u003csummary class=\"dg-summary\"\u003e\n    Let\u0026rsquo;s make a game! I have a big graveyard of unfinished hobby projects, so I\nhave no idea how far I\u0026rsquo;ll get. But as long as learning ensues, I\u0026rsquo;m fine with\nthat.\n\u003c/summary\u003e","title":"Robot Worlds 1: Walking Skeleton"},{"content":"My name is Dirk Groot, born in 1977, and I am a software engineer and architect. Programming has been my greatest passion since my early teens.\nWhen I was about 10 years old, my uncle gave me a Commodore 64. With it, he also gave me some C64 magazines. These magazines contained some information about programming, which I found very interesting. Not long afterwards, programming was my biggest hobby.\nSince I started working as a software engineer in 1997, I\u0026rsquo;ve worked on many different kinds of software: Embedded, windows forms, frontend, backend, transaction oriented, batch oriented, etc. I\u0026rsquo;ve also used many programming languages, and I\u0026rsquo;m always eager to learn more. Currently, my favourites are Kotlin, TypeScript and Clojure.\nI\u0026rsquo;m also really passionate about software design, architecture and agile software development. I\u0026rsquo;m particularly fond of test-driven development, YAGNI, and Kent Beck\u0026rsquo;s four rules of simple design.\nPrivate life I\u0026rsquo;m married, and we have 3 children (all teenagers). When I\u0026rsquo;m not programming, I like to run, take hikes in the many forests in and around Arnhem, watch movies and series, read a book, and occasionally play a video game.\n","permalink":"https://blog.dirkgroot.nl/about/","summary":"My name is Dirk Groot, born in 1977, and I am a software engineer and architect. Programming has been my greatest passion since my early teens.\nWhen I was about 10 years old, my uncle gave me a Commodore 64. With it, he also gave me some C64 magazines. These magazines contained some information about programming, which I found very interesting. Not long afterwards, programming was my biggest hobby.\nSince I started working as a software engineer in 1997, I\u0026rsquo;ve worked on many different kinds of software: Embedded, windows forms, frontend, backend, transaction oriented, batch oriented, etc.","title":"About"}]