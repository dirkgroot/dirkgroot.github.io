[{"content":" Ever had that sinking feeling when a bug sneaks into production, despite all your testing efforts? Yeah, we\u0026rsquo;ve all been there! While languages like Java, C#, and Kotlin come with powerful type systems, many developers aren\u0026rsquo;t using them to their full potential.\nIn this series, we\u0026rsquo;ll explore how we can use types to catch bugs before they even have a chance to become bugs. We\u0026rsquo;ll look at practical ways to make our designs safer and easier to understand.\nIntroduction This is the first part of a series of articles I\u0026rsquo;m writing about designing with types. In the first two articles we\u0026rsquo;ll set the stage. In subsequent articles we\u0026rsquo;ll explore some practical ways of using types make our code safer and easier to understand.\nFeedback loops Before we dive in, let\u0026rsquo;s consider why this is relevant. While developing software, we are constantly faced with feedback loops. The diagram below shows a simplified version of a typical development process.\nThis diagram shows three types of feedback we could get after we make a change. The build pipeline could fail, a code reviewer could give valuable feedback, or someone could find a bug while manually testing the change.\nFrom this small example, we can easily see that we\u0026rsquo;re more productive when we have short feedback loops. Solving the bugs we inevitably introduce takes longer when more steps are between making the change and receiving feedback. If receiving feedback takes a long time, we\u0026rsquo;ll go do something else in the meantime. This causes context switching which, as we know, is a big productivity killer.\nFinding bugs Development processes like the one shown above typically have multiple ways of finding bugs after they have been introduced. For example:\nCode review Automated tests Manual / exploratory tests Acceptance test Collect end user feedback etc\u0026hellip; We need to do stuff like this. If you\u0026rsquo;re doing all this, good job!\nPreventing bugs There are also multiple ways to prevent bugs from occurring in the first place, for example:\nBacklog refinement Developing in small, safe steps Test-Driven Development ðŸŽ‡ Design ðŸŽ‡ Design is what this series is about. We\u0026rsquo;ll explore several ways of using carefully designed types to make illegal states unrepresentable1. Code that introduces an illegal state should not compile.\nDesign Strategy As shown before, we typically spend a lot of time and effort on finding bugs in our software. This is a good thing. Mistakes will always be made and cannot be 100% prevented, not even by the techniques we\u0026rsquo;ll be exploring in this series. However, from what I\u0026rsquo;ve seen \u0026ldquo;in the wild\u0026rdquo;, I do think we tend to miss a lot of opportunities to design our software in ways that prevent bugs from being introduced.\nThe overall strategy we\u0026rsquo;ll be exploring is to prevent bugs by carefully designing a domain model. This domain model implements business rules and should be considered an API that is used by our application logic. The domain model should consist of carefully designed types that make it impossible to build application logic that introduces illegal states in our application. Ideally, mistakes in our application logic are found by the compiler.\nDesign goals In short, the design goals for our domain model are to create an API that:\nis safe to use reveals intent Safety One common cause of bugs is misusing the API of the domain model. Some examples are:\nAssigning invalid values to properties Changing a property of an entity while not allowed Changing the \u0026ldquo;workflow\u0026rdquo; status of an entity while not allowed Calling functions while not allowed Having functions without proper input validation and calling them with invalid parameter values All of this can and will happen, when the API\u0026rsquo;s we design allow for such mistakes to be made.\nSo what do I mean when I say we should design APIs that are safe to use? It means we should aim to design API\u0026rsquo;s that can be used without having to wonder whether they are safe to use in a particular situation. To achieve this, we should prefer compile time validation over runtime validation. When you use an API in an invalid way, the code should not compile.\nRevealing intent Problems like the ones mentioned above also tend to happen when developers misunderstand the intended purpose of APIs. An obvious reason for this is lack of proper naming. For example, completeOrder reveals a lot more intent than setStatus.\nAnother, more subtle, naming problem is that we tend to just not name things. We\u0026rsquo;ll be looking at several examples of this in subsequent articles. As a preparatory exercise, you can look at the code you\u0026rsquo;re working on and see if you can find concepts that are implemented, but not explicitly named.\nAs you will see, safety and revealing intent often go hand in hand. When we improve the safety of your code, we will likely also make the code easier to understand and vice versa.\nNext up In the next article we\u0026rsquo;ll do some more setting the stage by reviewing some commonly seen code. In subsequent articles we\u0026rsquo;ll explore ways of improving the safety and readability of our code.\nThis phrase was coined by Yaron Minsky\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://dirkgroot.nl/posts/series/designing-with-types/01-intro/","summary":"\u003csummary class=\"dg-summary\"\u003e\n    \u003cp\u003eEver had that sinking feeling when a bug sneaks into production, despite all your testing efforts? Yeah, we\u0026rsquo;ve all been\nthere! While languages like Java, C#, and Kotlin come with powerful type systems, many developers aren\u0026rsquo;t using them to\ntheir full potential.\u003c/p\u003e\n\u003cp\u003eIn this series, we\u0026rsquo;ll explore how we can use types to catch bugs before they even have a chance to become bugs. We\u0026rsquo;ll\nlook at practical ways to make our designs safer and easier to understand.\u003c/p\u003e\n\n\u003c/summary\u003e","title":"Designing with types #01: Introduction"},{"content":"My name is Dirk Groot, born in 1977, and I am a software engineer and architect. Programming has been my greatest passion since my early teens.\nWhen I was about 10 years old, my uncle gave me a Commodore 64. With it, he also gave me some C64 magazines. These magazines contained some information about programming, which I found very interesting. Not long afterwards, programming was my biggest hobby.\nSince I started working as a software engineer in 1997, I\u0026rsquo;ve worked on many different kinds of software: Embedded, windows forms, frontend, backend, transaction oriented, batch oriented, etc. I\u0026rsquo;ve also used many programming languages, and I\u0026rsquo;m always eager to learn more. Currently, my favourites are Kotlin, TypeScript and Clojure.\nI\u0026rsquo;m also really passionate about software design, architecture and agile software development. I\u0026rsquo;m particularly fond of test-driven development, YAGNI, and Kent Beck\u0026rsquo;s four rules of simple design.\nPrivate life I\u0026rsquo;m married, and we have 3 children (all teenagers). When I\u0026rsquo;m not programming, I like to run, take hikes in the many forests in and around Arnhem, watch movies and series, read a book, and occasionally play a video game.\n","permalink":"https://dirkgroot.nl/about/","summary":"\u003cp\u003eMy name is Dirk Groot, born in \u003ca href=\"https://en.wikipedia.org/wiki/1977\"\u003e1977\u003c/a\u003e, and I am a software engineer and architect. Programming\nhas been my greatest passion since my early teens.\u003c/p\u003e\n\u003cp\u003eWhen I was about 10 years old, my uncle gave me a Commodore 64. With it, he also gave me some C64 magazines. These magazines\ncontained some information about programming, which I found very interesting. Not long afterwards, programming was my biggest hobby.\u003c/p\u003e\n\u003cp\u003eSince I started working as a software engineer in 1997, I\u0026rsquo;ve worked on many different kinds of software: Embedded, windows forms,\nfrontend, backend, transaction oriented, batch oriented, etc. I\u0026rsquo;ve also used many programming languages, and I\u0026rsquo;m always eager to\nlearn more. Currently, my favourites are Kotlin, TypeScript and Clojure.\u003c/p\u003e","title":"About"}]