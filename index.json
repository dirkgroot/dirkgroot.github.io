[{"content":" Let's make a game! I have a big graveyard of unfinished hobby projects, so I have no idea how far I'll get. But as long as learning ensues, I'm fine with that. Intro I created this blog site 6 months ago, so I guess it\u0026rsquo;s about time to actually start writing üôÑ. Here goes nothing!\nGeepaw Hill and Ron Jeffries both started a (v|b)log series on a fun programming exercise called Robot Worlds. From what I understand from these blogs, this exercise is part of an education offered by WeThinkCode_, which helps young South Africans train their digital skills.\nI really like doing these kinds of exercises, mainly because they are an excellent way of practicing my test-driven development skills, and a nice programming challenge in general. So let\u0026rsquo;s give it a go, shall we?\nYou can view the source code on GitHub: https://github.com/dirkgroot/robot-worlds.\nWhat is Robot Worlds? Robot Worlds is a multiplayer game in which the player controls a robot in a world full of obstacles, pits, and other robots. Robots can move around, scan their surroundings, shoot, and place mines. It consists of a client and a server, which communicate over a TCP socket connection, using messages in JSON format. Check out Hill\u0026rsquo;s GitHub repository for the specifications.\nThe container diagram1 below shows my current understanding of the architecture of the game.\nWalking skeleton Both Hill and Jeffries start out by building what\u0026rsquo;s called a \u0026ldquo;walking skeleton\u0026rdquo;, and I\u0026rsquo;ll be doing that as well. The term \u0026ldquo;walking skeleton\u0026rdquo; was coined by Alistair Cockburn, and the GOOS book describes it as follows:\nA ‚Äúwalking skeleton‚Äù is an implementation of the thinnest possible slice of real functionality that we can automatically build, deploy, and test end-to-end. It should include just enough of the automation, the major components, and communication mechanisms to allow us to start working on the first feature.\nHill and Jeffries have also given some valuable insights about what a walking skeleton is, and why it\u0026rsquo;s so useful. Check out their articles, they are really good!\nMy plan is to follow the definition of the GOOS book rather closely. This means I\u0026rsquo;ll create a client and a server application with just enough functionality to justify their existence and the need for communication between the client and the server.\nLet\u0026rsquo;s get started! Project setup First things first, let\u0026rsquo;s set up a basic project. I\u0026rsquo;ll be using Kotlin as my programming language, and IntelliJ IDEA as my IDE. I\u0026rsquo;ve set up a multi-module Gradle project with 2 modules to start with: client and server:\nrobot-worlds |... |- client | |- src/main/kotlin | |- src/test/kotlin | |- build.gradle.kts |... |- server | |- src/main/kotlin | |- src/test/kotlin | |- build.gradle.kts |... |- settings.gradle.kts Launch! So, what\u0026rsquo;s the \u0026ldquo;thinnest possible slice of real functionality\u0026rdquo; we could implement in our walking skeleton? Launching a robot into the world seems like a good candidate. To launch a robot into the world, the client must send a launch command to the server with some arguments, describing the robot it wants to launch. If all is well, the server then responds with a message containing an OK result and the current state of the robot (position, orientation, etc).\nI\u0026rsquo;d like to make this slice even thinner. Let\u0026rsquo;s start by implementing a very minimal version of the launch command and response. We\u0026rsquo;re leaving out the arguments from the command, and the state from the response. Furthermore, we\u0026rsquo;ll only implement the happy flow.\nThis is how the first version of the launch command will look:\n{ \u0026#34;command\u0026#34;: \u0026#34;launch\u0026#34; } The response will look like this:\n{ \u0026#34;result\u0026#34;: \u0026#34;OK\u0026#34; } So, where to begin? Although this is indeed a very thin slice of real functionality, it\u0026rsquo;s still functionality that requires all major parts of the application to be in place. That way we can test it end-to-end. We need a client and a server, both need some kind of user interface, and the client needs to send commands to the server over a TCP socket.\nLet\u0026rsquo;s start from the bottom of the call stack, and step by step work our way upwards. What do I mean by this? This sequence diagram is a rough sketch of the call stack I currently have in mind.\nJust rotate your screen 90 degrees clockwise, and you\u0026rsquo;ll see what I mean. The top of the call stack is where everything starts: the Player. With every arrow we dive a level deeper into the call stack, until we arrive at World. So the bottom of the call stack in this case is World.\nWorld-class Let\u0026rsquo;s start nice and simple. First, write a test.\nclass WorldTest { @Test fun `no robots in a new world`() { val world = World() assertThat(world.robotCount).isZero() } } Making it pass is easy.\nclass World { val robotCount: Int = 0 } For our slice, we need a way to launch a robot into the world.\n@Test fun `launch a robot into the world`() { val world = World() world.launchRobot() assertThat(world.robotCount).isEqualTo(1) } We don\u0026rsquo;t have a launchRobot function yet, so make it compile first.\nclass World { val robotCount: Int = 0 fun launchRobot() { } } Our test fails, of course: expected:\u0026lt;[1]\u0026gt; but was:\u0026lt;[0]\u0026gt;. Let\u0026rsquo;s make it pass. We\u0026rsquo;ll make the robotCount a var instead of a val, to be able to update it\u0026rsquo;s value.\nvar robotCount: Int = 0 fun launchRobot() { robotCount++ } Now the robotCount property can be updated by everyone. Let\u0026rsquo;s make the setter private, so only World can update it.\nvar robotCount: Int = 0 private set Our tests still pass, so I guess the head of our walking skeleton is done üíÄ. It doesn\u0026rsquo;t have much of a brain yet, but with the amount of intelligence it currently has, I\u0026rsquo;d call it \u0026ldquo;undead\u0026rdquo;.\nRequest to launch Looking at the protocol specification, we can see that every interaction between client and server is initiated by the client. The communication style is request-response. The client requests the server to execute a command, and the server replies with a result.\nSo, if we move one step up the call stack from World::launch, what would we need? I think it\u0026rsquo;s a function that takes a request and executes the requested command. Let\u0026rsquo;s implement this without worrying about (de)serializing from/to JSON yet. We\u0026rsquo;ll start by adding a test to WorldTest.\n@Test fun `execute a launch command`() { val world = World() world.handleRequest(Request(command = \u0026#34;launch\u0026#34;)) assertThat(world.robotCount).isEqualTo(1) } This doesn\u0026rsquo;t compile, because we don\u0026rsquo;t have a Request class, and World doesn\u0026rsquo;t have a handleRequest method. Let\u0026rsquo;s start by letting IntelliJ generate a Request class for us (I\u0026rsquo;m lazy).\nclass Request(command: String) Easy. Now, IntelliJ can generate the World::handleRequest method as well.\nfun handleRequest(request: Request) { } Now our test compiles, but it fails: expected:\u0026lt;[1]\u0026gt; but was:\u0026lt;[0]\u0026gt;, so let\u0026rsquo;s make it pass.\nfun handleRequest(request: Request) { launchRobot() } Yep, that\u0026rsquo;s all we need for now.\nReally? Remember the description from the GOOS book earlier in this post. Our goal here is not to build an entire feature:\n[\u0026hellip;] It should include just enough of the automation, the major components, and communication mechanisms to allow us to start working on the first feature.\nWe just want to get all the stuff in place that we need to build and test our first feature end-to-end. In a real-world project this would typically include setting up build scripts, CI/CD, deployment to DTAP environments, etc. By doing this first, we benefit from having all this from the very start. Immediately, we have everything in place to make sure that every bit of functionality we add is well-tested, well-factored and potentially shippable.\nSummary We started out by drawing a little architecture diagram to get an overview of the major parts of the game that we\u0026rsquo;re building. Later on, the sequence diagram helped us choose a starting point for writing some actual code. I feel like that was just enough \u0026ldquo;design up front\u0026rdquo; to get me started.\nWe got some of the boring project set up stuff out of the way. The project is set up and a tiny part of a tiny slice of functionality is in place. The World class will almost certainly be split up into the actual game logic and one or more other classes which handle requests from the client. We could have chosen to do that right now, but we can also do it later. I don\u0026rsquo;t think it\u0026rsquo;s really important right now.\nFor now, our goal is to put the major components in place, and World is one of them. The next steps up the call stack will most likely be the TCP socket connection and (de)serialization of messages.\nSo there it is, 6 months after setting it up, this blog has finally officially been kicked off. I hope you enjoyed my first post. I certainly enjoyed writing it. Stay tuned for the next one!\nThe container diagram is one of the 4 core diagrams of the C4 model for visualising software architecture.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://blog.dirkgroot.nl/posts/robot-worlds/01-walking-skeleton/","summary":"\u003csummary\u003e\n    \nLet's make a game! I have a big graveyard of unfinished hobby projects, so I\nhave no idea how far I'll get. But as long as learning ensues, I'm fine with\nthat.\n\n\u003c/summary\u003e","title":"Robot Worlds 1: Walking Skeleton"},{"content":"My name is Dirk Groot, born in 1977, and I am a software engineer and architect. Programming has been my greatest passion since my early teens.\nWhen I was about 10 years old, my uncle gave me a Commodore 64. With it, he also gave me some C64 magazines. These magazines contained some information about programming, which I found very interesting. Not long afterwards, programming was my biggest hobby.\nSince I started working as a software engineer in 1997, I\u0026rsquo;ve worked on many different kinds of software: Embedded, windows forms, frontend, backend, transaction oriented, batch oriented, etc. I\u0026rsquo;ve also used many programming languages, and I\u0026rsquo;m always eager to learn more. Currently, my favourites are Kotlin, TypeScript and Clojure.\nI\u0026rsquo;m also really passionate about software design, architecture and agile software development. I\u0026rsquo;m particularly fond of test-driven development, YAGNI, and Kent Beck\u0026rsquo;s four rules of simple design.\nPrivate life I\u0026rsquo;m married, and we have 3 children (all teenagers). When I\u0026rsquo;m not programming, I like to run, take hikes in the many forests in and around Arnhem, watch movies and series, read a book, and occasionally play a video game.\n","permalink":"https://blog.dirkgroot.nl/about/","summary":"My name is Dirk Groot, born in 1977, and I am a software engineer and architect. Programming has been my greatest passion since my early teens.\nWhen I was about 10 years old, my uncle gave me a Commodore 64. With it, he also gave me some C64 magazines. These magazines contained some information about programming, which I found very interesting. Not long afterwards, programming was my biggest hobby.\nSince I started working as a software engineer in 1997, I\u0026rsquo;ve worked on many different kinds of software: Embedded, windows forms, frontend, backend, transaction oriented, batch oriented, etc.","title":"About"}]