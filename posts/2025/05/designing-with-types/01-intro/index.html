<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Designing with types #01: Introduction | Dirk Groot</title>
<meta name=keywords content="design,type safety,java"><meta name=description content="
    Ever had that sinking feeling when a bug sneaks into production, despite all your testing efforts? Yeah, we&rsquo;ve all been
there! While languages like Java, C#, and Kotlin come with powerful type systems, many developers aren&rsquo;t using them to
their full potential.
In this series, we&rsquo;ll explore how we can use types to catch bugs before they even have a chance to become bugs. We&rsquo;ll
look at practical ways to make our designs safer and easier to understand.

"><meta name=author content="Dirk Groot"><link rel=canonical href=https://dirkgroot.nl/posts/2025/05/designing-with-types/01-intro/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://dirkgroot.nl/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dirkgroot.nl/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dirkgroot.nl/favicon-32x32.png><link rel=apple-touch-icon href=https://dirkgroot.nl/apple-touch-icon.png><link rel=mask-icon href=https://dirkgroot.nl/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dirkgroot.nl/posts/2025/05/designing-with-types/01-intro/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=/css/theme-overrides.css><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><script src=https://cdn.jsdelivr.net/gh/sprucejoy/cookie-consent-autoblock-gdpr/cookie-consent.js crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TBE6V39YXJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TBE6V39YXJ")}</script><meta property="og:url" content="https://dirkgroot.nl/posts/2025/05/designing-with-types/01-intro/"><meta property="og:site_name" content="Dirk Groot"><meta property="og:title" content="Designing with types #01: Introduction"><meta property="og:description" content=" Ever had that sinking feeling when a bug sneaks into production, despite all your testing efforts? Yeah, we‚Äôve all been there! While languages like Java, C#, and Kotlin come with powerful type systems, many developers aren‚Äôt using them to their full potential.
In this series, we‚Äôll explore how we can use types to catch bugs before they even have a chance to become bugs. We‚Äôll look at practical ways to make our designs safer and easier to understand."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-21T06:12:50+00:00"><meta property="article:modified_time" content="2025-05-21T06:12:50+00:00"><meta property="article:tag" content="Design"><meta property="article:tag" content="Type Safety"><meta property="article:tag" content="Java"><meta name=twitter:card content="summary"><meta name=twitter:title content="Designing with types #01: Introduction"><meta name=twitter:description content="
    Ever had that sinking feeling when a bug sneaks into production, despite all your testing efforts? Yeah, we&rsquo;ve all been
there! While languages like Java, C#, and Kotlin come with powerful type systems, many developers aren&rsquo;t using them to
their full potential.
In this series, we&rsquo;ll explore how we can use types to catch bugs before they even have a chance to become bugs. We&rsquo;ll
look at practical ways to make our designs safer and easier to understand.

"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dirkgroot.nl/posts/"},{"@type":"ListItem","position":2,"name":"Designing with types #01: Introduction","item":"https://dirkgroot.nl/posts/2025/05/designing-with-types/01-intro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Designing with types #01: Introduction","name":"Designing with types #01: Introduction","description":" Ever had that sinking feeling when a bug sneaks into production, despite all your testing efforts? Yeah, we\u0026rsquo;ve all been there! While languages like Java, C#, and Kotlin come with powerful type systems, many developers aren\u0026rsquo;t using them to their full potential.\nIn this series, we\u0026rsquo;ll explore how we can use types to catch bugs before they even have a chance to become bugs. We\u0026rsquo;ll look at practical ways to make our designs safer and easier to understand.\n","keywords":["design","type safety","java"],"articleBody":" Ever had that sinking feeling when a bug sneaks into production, despite all your testing efforts? Yeah, we‚Äôve all been there! While languages like Java, C#, and Kotlin come with powerful type systems, many developers aren‚Äôt using them to their full potential.\nIn this series, we‚Äôll explore how we can use types to catch bugs before they even have a chance to become bugs. We‚Äôll look at practical ways to make our designs safer and easier to understand.\nIntroduction This is the first part of a series of articles I‚Äôm writing about designing with types. In the first two articles we‚Äôll set the stage. In subsequent articles we‚Äôll explore some practical ways of using types make our code safer and easier to understand.\nFeedback loops Before we dive in, let‚Äôs consider why this is relevant. While developing software, we are constantly faced with feedback loops. The diagram below shows a simplified version of a typical development process.\nThis diagram shows three types of feedback we could get after we make a change. The build pipeline could fail, a code reviewer could give valuable feedback, or someone could find a bug while manually testing the change.\nFrom this small example, we can easily see that we‚Äôre more productive when we have short feedback loops. Solving the bugs we inevitably introduce takes longer when more steps are between making the change and receiving feedback. If receiving feedback takes a long time, we‚Äôll go do something else in the meantime. This causes context switching which, as we know, is a big productivity killer.\nFinding bugs Development processes like the one shown above typically have multiple ways of finding bugs after they have been introduced. For example:\nCode review Automated tests Manual / exploratory tests Acceptance test Collect end user feedback etc‚Ä¶ We need to do stuff like this. If you‚Äôre doing all this, good job!\nPreventing bugs There are also multiple ways to prevent bugs from occurring in the first place, for example:\nBacklog refinement Developing in small, safe steps Test-Driven Development üéá Design üéá Design is what this series is about. We‚Äôll explore several ways of using carefully designed types to make illegal states unrepresentable1. Code that introduces an illegal state should not compile.\nDesign Strategy As shown before, we typically spend a lot of time and effort on finding bugs in our software. This is a good thing. Mistakes will always be made and cannot be 100% prevented, not even by the techniques we‚Äôll be exploring in this series. However, from what I‚Äôve seen ‚Äúin the wild‚Äù, I do think we tend to miss a lot of opportunities to design our software in ways that prevent bugs from being introduced.\nThe overall strategy we‚Äôll be exploring is to prevent bugs by carefully designing a domain model. This domain model implements business rules and should be considered an API that is used by our application logic. The domain model should consist of carefully designed types that make it impossible to build application logic that introduces illegal states in our application. Ideally, mistakes in our application logic are found by the compiler.\nDesign goals In short, the design goals for our domain model are to create an API that:\nis safe to use reveals intent Safety One common cause of bugs is misusing the API of the domain model. Some examples are:\nAssigning invalid values to properties Changing a property of an entity while not allowed Changing the ‚Äúworkflow‚Äù status of an entity while not allowed Calling functions while not allowed Having functions without proper input validation and calling them with invalid parameter values All of this can and will happen, when the API‚Äôs we design allow for such mistakes to be made.\nSo what do I mean when I say we should design APIs that are safe to use? It means we should aim to design API‚Äôs that can be used without having to wonder whether they are safe to use in a particular situation. To achieve this, we should prefer compile time validation over runtime validation. When you use an API in an invalid way, the code should not compile.\nRevealing intent Problems like the ones mentioned above also tend to happen when developers misunderstand the intended purpose of APIs. An obvious reason for this is lack of proper naming. For example, completeOrder reveals a lot more intent than setStatus.\nAnother, more subtle, naming problem is that we tend to just not name things. We‚Äôll be looking at several examples of this in subsequent articles. As a preparatory exercise, you can look at the code you‚Äôre working on and see if you can find concepts that are implemented, but not explicitly named.\nAs you will see, safety and revealing intent often go hand in hand. When we improve the safety of your code, we will likely also make the code easier to understand and vice versa.\nNext up In the next article we‚Äôll do some more setting the stage by reviewing some commonly seen code. In subsequent articles we‚Äôll explore ways of improving the safety and readability of our code.\nThis phrase was coined by Yaron Minsky¬†‚Ü©Ô∏é\n","wordCount":"856","inLanguage":"en","datePublished":"2025-05-21T06:12:50Z","dateModified":"2025-05-21T06:12:50Z","author":{"@type":"Person","name":"Dirk Groot"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dirkgroot.nl/posts/2025/05/designing-with-types/01-intro/"},"publisher":{"@type":"Organization","name":"Dirk Groot","logo":{"@type":"ImageObject","url":"https://dirkgroot.nl/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://dirkgroot.nl/ accesskey=h title="Dirk Groot (Alt + H)">Dirk Groot</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://dirkgroot.nl/ title=Blog><span>Blog</span></a></li><li><a href=https://dirkgroot.nl/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dirkgroot.nl/series/ title=Series><span>Series</span></a></li><li><a href=https://dirkgroot.nl/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://dirkgroot.nl/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://dirkgroot.nl/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dirkgroot.nl/>Home</a>&nbsp;¬ª&nbsp;<a href=https://dirkgroot.nl/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Designing with types #01: Introduction</h1><div class=post-meta><span title='2025-05-21 06:12:50 +0000 UTC'>May 21, 2025</span>&nbsp;¬∑&nbsp;5 min&nbsp;¬∑&nbsp;Dirk Groot</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#feedback-loops aria-label="Feedback loops">Feedback loops</a><ul><li><a href=#finding-bugs aria-label="Finding bugs">Finding bugs</a></li><li><a href=#preventing-bugs aria-label="Preventing bugs">Preventing bugs</a></li></ul></li><li><a href=#design aria-label=Design>Design</a><ul><li><a href=#strategy aria-label=Strategy>Strategy</a></li><li><a href=#design-goals aria-label="Design goals">Design goals</a><ul><li><a href=#safety aria-label=Safety>Safety</a></li><li><a href=#revealing-intent aria-label="Revealing intent">Revealing intent</a></li></ul></li></ul></li><li><a href=#next-up aria-label="Next up">Next up</a></li></ul></div></details></div><div class=post-content><summary class=dg-summary><p>Ever had that sinking feeling when a bug sneaks into production, despite all your testing efforts? Yeah, we&rsquo;ve all been
there! While languages like Java, C#, and Kotlin come with powerful type systems, many developers aren&rsquo;t using them to
their full potential.</p><p>In this series, we&rsquo;ll explore how we can use types to catch bugs before they even have a chance to become bugs. We&rsquo;ll
look at practical ways to make our designs safer and easier to understand.</p></summary><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>This is the first part of a series of articles I&rsquo;m writing about designing with types. In the first two articles we&rsquo;ll
set the stage. In subsequent articles we&rsquo;ll explore some practical ways of using types make our code safer and easier to
understand.</p><h2 id=feedback-loops>Feedback loops<a hidden class=anchor aria-hidden=true href=#feedback-loops>#</a></h2><p>Before we dive in, let&rsquo;s consider why this is relevant. While developing software, we are constantly faced with feedback
loops. The diagram below shows a simplified version of a typical development process.</p><figure class="dg-figure-border dg-figure-padding"><img loading=lazy src=feedback-loops.svg width=400px></figure><p>This diagram shows three types of feedback we could get after we make a change. The build pipeline could fail, a code
reviewer could give valuable feedback, or someone could find a bug while manually testing the change.</p><p>From this small example, we can easily see that we&rsquo;re more productive when we have short feedback loops. Solving the
bugs we inevitably introduce takes longer when more steps are between making the change and receiving feedback. If
receiving feedback takes a long time, we&rsquo;ll go do something else in the meantime. This causes context switching which,
as we know, is a big productivity killer.</p><h3 id=finding-bugs>Finding bugs<a hidden class=anchor aria-hidden=true href=#finding-bugs>#</a></h3><p>Development processes like the one shown above typically have multiple ways of finding bugs after they have been
introduced. For example:</p><ul><li>Code review</li><li>Automated tests</li><li>Manual / exploratory tests</li><li>Acceptance test</li><li>Collect end user feedback</li><li>etc&mldr;</li></ul><p>We need to do stuff like this. If you&rsquo;re doing all this, good job!</p><figure><img loading=lazy src=https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExNmxsNHRmd2lkODFvbnhtcjBhdzdyaXMwbTcweGd3bzdpZjN5d2htMiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/mGK1g88HZRa2FlKGbz/giphy.gif width=200px></figure><h3 id=preventing-bugs>Preventing bugs<a hidden class=anchor aria-hidden=true href=#preventing-bugs>#</a></h3><p>There are also multiple ways to prevent bugs from occurring in the first place, for example:</p><ul><li>Backlog refinement</li><li>Developing in small, safe steps</li><li>Test-Driven Development</li><li>üéá <strong>Design</strong> üéá</li></ul><p><strong>Design</strong> is what this series is about. We&rsquo;ll explore several ways of using carefully designed types to <strong>make
illegal states unrepresentable</strong><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Code that introduces an illegal state should not compile.</p><figure><img loading=lazy src=https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExeHU0bTZianlqZWJ3NjFzNXFvNTI3bHFodXhzZjUwaDFqajZlMjZsdCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/26ufdipQqU2lhNA4g/giphy.gif width=200px></figure><h2 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h2><h3 id=strategy>Strategy<a hidden class=anchor aria-hidden=true href=#strategy>#</a></h3><p>As shown before, we typically spend a lot of time and effort on finding bugs in our software. This is a good thing.
Mistakes will always be made and cannot be 100% prevented, not even by the techniques we&rsquo;ll be exploring in this series.
However, from what I&rsquo;ve seen &ldquo;in the wild&rdquo;, I do think we tend to miss a lot of opportunities to design our software in
ways that <strong>prevent</strong> bugs from being introduced.</p><p>The overall strategy we&rsquo;ll be exploring is to prevent bugs by carefully designing a <strong>domain model</strong>. This domain model
implements business rules and should be considered an <strong>API</strong> that is used by our application logic. The domain model
should consist of carefully designed types that make it impossible to build application logic that introduces illegal
states in our application. Ideally, mistakes in our application logic are found by the compiler.</p><h3 id=design-goals>Design goals<a hidden class=anchor aria-hidden=true href=#design-goals>#</a></h3><p>In short, the design goals for our domain model are to create an API that:</p><ul><li>is <strong>safe</strong> to use</li><li>reveals <strong>intent</strong></li></ul><h4 id=safety>Safety<a hidden class=anchor aria-hidden=true href=#safety>#</a></h4><p>One common cause of bugs is misusing the API of the domain model. Some examples are:</p><ul><li>Assigning invalid values to properties</li><li>Changing a property of an entity while not allowed</li><li>Changing the &ldquo;workflow&rdquo; status of an entity while not allowed</li><li>Calling functions while not allowed</li><li>Having functions without proper input validation and calling them with invalid parameter values</li></ul><p>All of this can and <strong>will</strong> happen, when the API&rsquo;s we design allow for such mistakes to be made.</p><p>So what do I mean when I say we should design APIs that are safe to use? It means we should aim to design API&rsquo;s that can
be used without having to wonder whether they are safe to use in a particular situation. To achieve this, we should
prefer compile time validation over runtime validation. When you use an API in an invalid way, the code should not
compile.</p><h4 id=revealing-intent>Revealing intent<a hidden class=anchor aria-hidden=true href=#revealing-intent>#</a></h4><p>Problems like the ones mentioned above also tend to happen when developers misunderstand the intended purpose of APIs.
An obvious reason for this is lack of proper naming. For example, <code>completeOrder</code> reveals a lot more intent than
<code>setStatus</code>.</p><p>Another, more subtle, naming problem is that we tend to just not name things. We&rsquo;ll be looking at several examples of
this in subsequent articles. As a preparatory exercise, you can look at the code you&rsquo;re working on and see if you can
find concepts that are implemented, but not explicitly named.</p><p>As you will see, safety and revealing intent often go hand in hand. When we improve the safety of your code, we will
likely also make the code easier to understand and vice versa.</p><h2 id=next-up>Next up<a hidden class=anchor aria-hidden=true href=#next-up>#</a></h2><p>In the next article we&rsquo;ll do some more setting the stage by reviewing some commonly seen code. In subsequent articles
we&rsquo;ll explore ways of improving the safety and readability of our code.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This phrase was coined by <a href=https://blog.janestreet.com/effective-ml-revisited/>Yaron Minsky</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://dirkgroot.nl/tags/design/>Design</a></li><li><a href=https://dirkgroot.nl/tags/type-safety/>Type Safety</a></li><li><a href=https://dirkgroot.nl/tags/java/>Java</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://dirkgroot.nl/>Dirk Groot</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=dg-extended-footer><div class=social-icons><a href=https://github.com/dirkgroot target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://www.linkedin.com/in/dirkgroot77 target=_blank rel="noopener noreferrer me" title=Linkedin><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a><a href=https://x.com/dirk__groot target=_blank rel="noopener noreferrer me" title=X><svg viewBox="0 0 24 24" fill="currentcolor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>