<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Designing with types #02: Pitfalls and Practices | Dirk Groot</title><meta name=keywords content="design,type safety,java,kotlin,architecture,OO"><meta name=description content="
    In this installment of my Designing with Types series, we&rsquo;ll look at how some typical backend code is set up. We&rsquo;ll
identify some common pitfalls and identify best practices to avoid these pitfalls.
"><meta name=author content="Dirk Groot"><link rel=canonical href=https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/><link crossorigin=anonymous href=/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://dirkgroot.nl/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dirkgroot.nl/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dirkgroot.nl/favicon-32x32.png><link rel=apple-touch-icon href=https://dirkgroot.nl/apple-touch-icon.png><link rel=mask-icon href=https://dirkgroot.nl/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=/css/theme-overrides.css><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><script>!function(e,t){var n,s,o,i;t.__SV||(window.posthog=t,t._i=[],t.init=function(a,r,c){function d(e,t){var n=t.split(".");2==n.length&&(e=e[n[0]],t=n[1]),e[t]=function(){e.push([t].concat(Array.prototype.slice.call(arguments,0)))}}(n=e.createElement("script")).type="text/javascript",n.crossOrigin="anonymous",n.async=!0,n.src=r.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(i=e.getElementsByTagName("script")[0]).parentNode.insertBefore(n,i);var l=t;for(0[0]!==c?l=t[c]=[]:c="posthog",l.people=l.people||[],l.toString=function(e){var t="posthog";return"posthog"!==c&&(t+="."+c),e||(t+=" (stub)"),t},l.people.toString=function(){return l.toString(1)+".people (stub)"},o="init be ys Ss me gs ws capture Ne calculateEventProperties xs register register_once register_for_session unregister unregister_for_session Rs getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty Is ks createPersonProfile Ps bs opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing clear_opt_in_out_capturing $s debug Es getPageViewId captureTraceFeedback captureTraceMetric".split(" "),s=0;s<o.length;s++)d(l,o[s]);t._i.push([a,r,c])},t.__SV=1)}(document,window.posthog||[]),posthog.init("phc_C7a3Twl8BDeaz7aHzeDLGuJDgYNfanH69WV2E6PY5wL",{api_host:"https://eu.i.posthog.com",person_profiles:"identified_only"})</script><meta property="og:url" content="https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/"><meta property="og:site_name" content="Dirk Groot"><meta property="og:title" content="Designing with types #02: Pitfalls and Practices"><meta property="og:description" content=" In this installment of my Designing with Types series, we’ll look at how some typical backend code is set up. We’ll identify some common pitfalls and identify best practices to avoid these pitfalls. "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-30T09:02:40+00:00"><meta property="article:modified_time" content="2025-06-30T09:02:40+00:00"><meta property="article:tag" content="Design"><meta property="article:tag" content="Type Safety"><meta property="article:tag" content="Java"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="OO"><meta property="og:image" content="https://dirkgroot.nl/cover.png"><meta property="og:see_also" content="https://dirkgroot.nl/posts/series/designing-with-types/01-intro/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dirkgroot.nl/cover.png"><meta name=twitter:title content="Designing with types #02: Pitfalls and Practices"><meta name=twitter:description content="
    In this installment of my Designing with Types series, we&rsquo;ll look at how some typical backend code is set up. We&rsquo;ll
identify some common pitfalls and identify best practices to avoid these pitfalls.
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dirkgroot.nl/posts/"},{"@type":"ListItem","position":2,"name":"Designing with types #02: Pitfalls and Practices","item":"https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Designing with types #02: Pitfalls and Practices","name":"Designing with types #02: Pitfalls and Practices","description":" In this installment of my Designing with Types series, we\u0026rsquo;ll look at how some typical backend code is set up. We\u0026rsquo;ll identify some common pitfalls and identify best practices to avoid these pitfalls. ","keywords":["design","type safety","java","kotlin","architecture","OO"],"articleBody":" In this installment of my Designing with Types series, we’ll look at how some typical backend code is set up. We’ll identify some common pitfalls and identify best practices to avoid these pitfalls. Architecture Regardless of what architecture style we use, an application almost always consists of three basic tiers or layers: Presentation, Business and Infrastructure. Here’s a diagram that shows two architecture styles using these three layers.\nIn the Hexagonal Architecture, the Business layer defines ports. The Presentation and Infrastructure layer contain adapters that interact with the web framework and the persistence framework. The Dependency Inversion Principle (DIP) is used to make the Business layer easy to test, because infrastructure-dependent code can easily be replaced by test doubles.\nIn the classic N-Tier Architecture, the responsibilities of the layers are the same, only the dependency rules are different from the Hexagonal Architecture.\nLet’s look at some examples of code we often encounter in these three layers.\nInfrastructure As mentioned in the diagram above, this is the layer where database communication usually happens. It’s also commonly known as the Data Access or Persistence layer. I’m calling it Infrastructure because it can be used for more than just persistence.\nWhen used for data access, this layer usually consists of database entities and repositories. Here’s an example in Kotlin, using JPA annotations for object-relational mapping (ORM) and Spring Data’s CrudRepository to generate a repository implementation:\n@Entity data class TodoList( @Id val id: UUID, var name: String ) { @OneToMany(mappedBy = \"todoList\", cascade = [CascadeType.ALL]) val items: MutableList = mutableListOf() } @Entity data class TodoItem( @Id val id: UUID, @ManyToOne @JoinColumn(name = \"todolist_id\", nullable = false) val todoList: TodoList, var title: String, var dueDate: LocalDateTime? = null, var done: Boolean = false, ) @Repository interface TodoListRepository : CrudRepository @Repository interface TodoItemRepository : CrudRepository { fun findByTodoListId(id: UUID): List } Business This layer contains the business logic of the application. Its responsibility is to make sure that business rules are enforced in the application. It usually consists of services that perform a certain task, using repositories and entities from the Infrastructure layer.\nHere’s a simple service that can create and remove todo lists (again, in Kotlin):\nclass TodoListService(val repository: TodoListRepository) { fun createTodoList(name: String): TodoList { require(name.isNotBlank()) { \"Name cannot be blank\" } val todoList = TodoList(UUID.randomUUID(), name) repository.save(todoList) return todoList } fun removeTodoList(todoListToRemove: TodoList) { if (todoListToRemove.items.any { !it.done }) { throw TodoListNotRemovableException() } repository.delete(todoListToRemove) } } This is a common pattern in these services. They check some business rules and if everything is okay, an action is performed. In this example, the business rules are that a todo list must have a name and that a todo list may only be deleted if all its todo items are done.\nHere’s an example that creates a new todo item:\nclass TodoItemService { fun create(id: UUID, description: String, dueDate: LocalDateTime?): TodoItem { if (dueDate != null \u0026\u0026 dueDate.isBefore(LocalDateTime.now())) throw InvalidDueDateException() val todoList = todoListRepository.findById(id).orElseThrow { TodoListNotFoundException() } val todoItem = TodoItem(id, todoList, description, dueDate) todoList.items.add(todoItem) todoListRepository.save(todoList) return todoItem } } In this example, besides input validation, we also ensure that we don’t try to add a todo item to a list that does not exist.\nPresentation In the variants mentioned earlier, the Presentation layer contains presentation and application logic. Alternatively, presentation and application logic can be assigned to separate layers. It contains functionality that is used by end users and uses the Business layer to validate and execute actions that users request. In a backend application that exposes a REST API (for example for a frontend or external systems), this layer contains REST controllers.\nHere’s an example of a REST controller, using annotations from Spring Web:\n@RestController @RequestMapping(\"/api/v1/todo/list\") class TodoListResource(private val todoListService: TodoListService) { @PostMapping fun create(@RequestParam name: String): ResponseEntity { val todoList = todoListService.createTodoList(name) return ResponseEntity.status(HttpStatus.CREATED) .body(TodoListRestModel.from(todoList)) } } The Business layer is used to create and store the new todo item. The controller makes sure that a HTTP response is returned, containing the newly created todo item.\nCode review These code examples are pretty simple and straightforward. That’s because the problem domain and the associated business rules are simple. You could argue that this code is perfectly fine for such a simple application, and I would agree.\nStill, I’d like to review this code with one important question in mind: Does it scale? Features will be added and existing features will be expanded. Systems grow bigger and more complicated, and so does the code. Ideally, we want our code to be designed in such a way that it stays maintainable while the system grows.\nDuplication While not directly obvious in the code above, we can see that we’re setting ourselves up for code duplication. For example, let’s expand our TodoListService with the ability to rename an existing todo list:\nfun createTodoList(name: String): TodoList { require(name.isNotBlank()) { \"Name cannot be blank\" } // ... return todoList } fun renameTodoList(id: UUID, name: String) { require(name.isNotBlank()) { \"Name cannot be blank\" } // ... } Now we have two functions that accept a name for a todo list. Obviously, a String can be blank, which we don’t want, so every time we use a String for accepting the name of a todo list, we need to check if that String contains a valid name.\nThis problem arises when parameter types accept more values than the domain we’re implementing allows for. If that’s the case, we need input validation to make sure our function is not used in an invalid way. This is an anti-pattern, called Primitive Obsession. Be aware that this isn’t limited to the usage of primitives. In general, when we use overly permissive parameter types, we likely need input validation.\nPublic mutable state Some of the state of entities in the Infrastructure layer can be changed by everyone. Take TodoItem for example:\n@Entity data class TodoItem( @Id val id: UUID, @ManyToOne @JoinColumn(name = \"todolist_id\", nullable = false) val todoList: TodoList, var title: String, var dueDate: LocalDateTime? = null, var done: Boolean = false, ) The fields title, dueDate and done have a public setter. This means it’s very easy to write code that violates business rules that are normally enforced by the Business layer. For example, we can easily introduce code that changes a todo item to have an empty title or creates a new todo item with a dueDate in the past.\nThis is an anti-pattern known as Inappropriate Intimacy or Object Orgy.\nLack of encapsulation The issue of public mutable state is a consequence of another design issue: Data and business logic are separated between different classes. Data is modeled as entities, services make sure that the data conforms to the business rules. The entities shown here are basically Data Transfer Objects (DTO’s). They tell the Object-Relational Mapper (ORM) what tables exist, which columns these tables consist of, et cetera.\nThese DTO’s are used thoughout the entire code base. While the Business layer should be enforcing business rules, it’s very easy to violate business rules by changing DTO’s in a REST controller, for example.\nWe’re using an object-oriented (OO) language, but by designing our code like this we don’t benefit from one of the main strengths of OO, which is that data and the associated behaviour are encapsulated in one class. This makes our code more error-prone than it needs to be.\nThere’s a bug! Maybe you already spotted it, there’s a bug in TodoItemService. Can you find it?\nfun create(id: UUID, description: String, dueDate: LocalDateTime?): TodoItem { if (dueDate != null \u0026\u0026 dueDate.isBefore(LocalDateTime.now())) throw InvalidDueDateException() val todoList = todoListRepository.findById(id).orElseThrow { TodoListNotFoundException() } val todoItem = TodoItem(id, todoList, description, dueDate) todoList.items.add(todoItem) todoListRepository.save(todoList) return todoItem } I’ve shown this code in several talks I’ve given, asking the participants to spot the bug. From my limited “testing” it seems that the bug is surprisingly hard to find just by looking at the code.\nNow, where’s the bug? It’s in this line:\nval todoItem = TodoItem(id, todoList, description, dueDate) The id that is passed to the constructor is the id of the containing TodoList! Let’s assume the database table for todo items has a proper primary key or a unique constraint. If that’s the case, this code will fail as soon as we try to add a second TodoItem to a TodoList, because a duplicate key will be inserted.\nThis is another example of Primitive Obsession. While UUID isn’t a primitive type in the strict sense of the word, it is a type that doesn’t tell us anything about what kind of ID it actually represents. When we see just a UUID, it can be hard to determine if it’s the ID of a todo list, a todo item, or something entirely unrelated to the domain.\nFun fact: This is a bug that I accidentally introduced when I was preparing this code for a talk. I decided to include it in the talk as an example of how Primitive Obsession can easily lead to bugs that can be hard to find.\nSmells To summarize, in these code examples we have identified a couple of code smells:\nPrimitive Obsession – By using primitives or other overly permissive types, we need to duplicate input validation. Also, it’s very easy to introduce bugs when multiple domain concepts are implemented using the same primitive type. Inappropriate Intimacy – Unrestricted write access to the state of an object can easily lead to violation of business rules. Lack of encapsulation – Data and behaviour are separated into different classes. Principles One way we can address the issues we found is by designing better types. In this chapter I’d like to provide some high-level principles and practices to help in designing better types. In future installments, we’ll explore these more in-depth.\nI’d like to mention two principles that I think are fundamental to designing with types. The principles are:\nIllegal states should be unrepresentable State changes should be encapsulated Illegal states should be unrepresentable 1 When writing code, the very first feedback we get about our code is from the compiler. This is the shortest possible feedback loop we can have.\nFor example, when we try to assign a string to an integer variable, the compiler will immediately complain.\nval i: Int = \"Hello World!\" // \u003c-- Compiler error So the idea behind this principle is that in order to make our feedback loop as short as possible, we prefer compile-time validation over runtime validation. We do this by designing types in such a way that it is impossible to write compiling code that introduces an illegal state.\nState changes should be encapsulated Whenever we’re using an object, we should be confident that the state of that object is valid. It’s hard to be confident about this when the state of an object is freely mutable by everyone. This is why we use encapsulation in OO.\nSo this principle means that we should make each class exclusively responsible for enforcing its own invariants. This implies that each class should have exclusive control over its own state changes.\nPrinciples in practice So how do we put these principles into practice? Let’s look at two simple examples.\nValue Object pattern This is such a simple design pattern, but it’s oh so powerful! A value object represents one single value. This can be a complex value consisting of multiple fields (i.e. amount and currency for money).\nA value object must conform to the following rules:\nIt is immutable It is self-validating The identity of the object is the value itself Let’s look at two examples:\ndata class Name(private val value: String) { init { require(value.isNotBlank()) { \"Name cannot be blank\" } require(value.lines().size == 1) { \"Name must have exactly one line\" } } } data class Description(private val value: String) { init { require(value.isNotBlank()) { \"Description cannot be blank\" } } } Here we have two value objects, Name and Description. Both classes encapsulate an immutable value. Both classes make sure that no invalid value is accepted. This is arguably the simplest possible example of encapsulation, but there are profound consequences:\nFunctions that accept a Name and/or a Description as a parameter don’t need input validation for these parameters, because that’s what the constructors have already done. We can safely assume that the arguments are valid. We write fewer tests, because if we don’t need input validation, we don’t need to unit tests input validation. We can’t confuse parameters. The following code does not compile, because we cannot pass a Description when a Name is expected. class TodoList(val id: TodoListID, name: Name) fun main() { val list = TodoList(TodoListID.create(), Description(\"Description\\nwith multiple lines\")) // \u003c-- Compiler error // ... } So here we see both principles in practice. We make illegal states unrepresentable because we cannot confuse values with different domains. The values in the value objects are encapsulated and guaranteed to be valid, which simplifies our code by eliminating the need for duplicated input validation.\nEncapsulation using sum types Here is a slightly more advanced example using a sum type:\nsealed interface TodoItem { val id: TodoItemID val description: Description data class Todo(override val id: TodoItemID, override val description: Description) : TodoItem { fun updateDescription(newDescription: Description) = this.copy(description = newDescription) fun markAsDone() = Done(id, description) } data class Done(override val id: TodoItemID, override val description: Description) : TodoItem } In this example, we model TodoItem as a value object. The states (todo and done) of a todo item are modeled as implementations of the TodoItem interface. The signatures of these types reveal that the description of a todo item in the todo state can be changed. Todo items that are done cannot be changed at all2.\nThis is another way we can make illegal states unrepresentable using types. In fact, we take it a step further because thanks to the sum type, we also make illegal state changes unrepresentable. The following code does not compile:\nval item: TodoItem = TodoItem.Done(TodoItemID.create(), Description(\"Do the laundry\")) val changed: TodoItem = when (item) { is TodoItem.Done -\u003e item.updateDescription(Description(\"Do the dishes\")) // \u003c-- Compiler error is TodoItem.Todo -\u003e item } The sum type forces us to check the state of the todo item, before attempting to do anything with it. If we don’t, the code simply won’t compile. Code that tries to change the description of a done todo item also doesn’t compile.\nConclusion A lot of the code I’ve seen and written during my career suffers to some degree from the problems mentioned in this article. As said, in simple, small systems there’s little harm in having some Primitive Obsession or lack of encapsulation. In such cases adding a lot of types can feel like overengineering. This is fine, as long as you are aware that the antipatterns can become problematic when the system grows.\nBy designing better types, we can make our code safer to use and easier to understand by explicitly revealing intent. In this article we’ve seen two simple examples of this.\nNext up, we’ll talk some more about safety and revealing intent and we’ll look at more examples of using types to our advantage.\nThis phrase was coined by Yaron Minsky. Scott Wlaschin wrote a very nice article about this, as part of his article series on designing with types using F#. ↩︎\nFor the Kotlin-savvy among you: Yes, I know about copy 😄. We’ll address that in a future installment of this series. ↩︎\n","wordCount":"2560","inLanguage":"en","image":"https://dirkgroot.nl/cover.png","datePublished":"2025-06-30T09:02:40Z","dateModified":"2025-06-30T09:02:40Z","author":{"@type":"Person","name":"Dirk Groot"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/"},"publisher":{"@type":"Organization","name":"Dirk Groot","logo":{"@type":"ImageObject","url":"https://dirkgroot.nl/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://dirkgroot.nl/ accesskey=h title="Dirk Groot (Alt + H)">Dirk Groot</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://dirkgroot.nl/ title=Blog><span>Blog</span></a></li><li><a href=https://dirkgroot.nl/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dirkgroot.nl/series/ title=Series><span>Series</span></a></li><li><a href=https://dirkgroot.nl/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://dirkgroot.nl/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://dirkgroot.nl/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dirkgroot.nl/>Home</a>&nbsp;»&nbsp;<a href=https://dirkgroot.nl/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Designing with types #02: Pitfalls and Practices</h1><div class=post-meta><span title='2025-06-30 09:02:40 +0000 UTC'>June 30, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Dirk Groot</div></header><figure class=entry-cover><img loading=eager srcset='https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/cover_hu_1148d24de6645ff5.png 360w,https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/cover_hu_82cb8789da4674c0.png 480w,https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/cover_hu_ccd0b9eeff096cb8.png 720w,https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/cover_hu_6b22e7d15640eb64.png 1080w,https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/cover_hu_1211af43e08c7a00.png 1500w,https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/cover.png 1584w' src=https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/cover.png sizes="(min-width: 768px) 720px, 100vw" width=1584 height=300 alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#architecture aria-label=Architecture>Architecture</a><ul><li><a href=#infrastructure aria-label=Infrastructure>Infrastructure</a></li><li><a href=#business aria-label=Business>Business</a></li><li><a href=#presentation aria-label=Presentation>Presentation</a></li></ul></li><li><a href=#code-review aria-label="Code review">Code review</a><ul><li><a href=#duplication aria-label=Duplication>Duplication</a></li><li><a href=#public-mutable-state aria-label="Public mutable state">Public mutable state</a></li><li><a href=#lack-of-encapsulation aria-label="Lack of encapsulation">Lack of encapsulation</a></li><li><a href=#theres-a-bug aria-label="There&rsquo;s a bug!">There&rsquo;s a bug!</a></li></ul></li><li><a href=#smells aria-label=Smells>Smells</a></li><li><a href=#principles aria-label=Principles>Principles</a><ul><li><a href=#illegal-states-should-be-unrepresentable aria-label="Illegal states should be unrepresentable 1">Illegal states should be unrepresentable 1</a></li><li><a href=#state-changes-should-be-encapsulated aria-label="State changes should be encapsulated">State changes should be encapsulated</a></li></ul></li><li><a href=#principles-in-practice aria-label="Principles in practice">Principles in practice</a><ul><li><a href=#value-object-pattern aria-label="Value Object pattern">Value Object pattern</a></li><li><a href=#encapsulation-using-sum-types aria-label="Encapsulation using sum types">Encapsulation using sum types</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><summary class=dg-summary>In this installment of my Designing with Types series, we&rsquo;ll look at how some typical backend code is set up. We&rsquo;ll
identify some common pitfalls and identify best practices to avoid these pitfalls.</summary><h2 id=architecture>Architecture<a hidden class=anchor aria-hidden=true href=#architecture>#</a></h2><p>Regardless of what architecture style we use, an application almost always consists of three basic tiers or layers:
<em>Presentation</em>, <em>Business</em> and <em>Infrastructure</em>. Here&rsquo;s a diagram that shows two architecture styles using these three
layers.</p><figure class="dg-figure-border dg-figure-padding"><img loading=lazy src=architecture.svg width=700px></figure><p>In the <a href=https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)>Hexagonal Architecture</a>, the <em>Business</em> layer
defines ports. The <em>Presentation</em> and <em>Infrastructure</em> layer contain adapters that interact with the web framework and
the persistence framework.
The <a href=https://en.wikipedia.org/wiki/Dependency_inversion_principle>Dependency Inversion Principle</a> (DIP) is used to make
the <em>Business</em> layer easy to test, because infrastructure-dependent code can easily be replaced
by <a href=https://en.wikipedia.org/wiki/Test_double>test doubles</a>.</p><p>In the classic <a href=https://en.wikipedia.org/wiki/Multitier_architecture>N-Tier Architecture</a>, the responsibilities of the
layers are the same, only the dependency rules are different from the Hexagonal Architecture.</p><p>Let&rsquo;s look at some examples of code we often encounter in these three layers.</p><h3 id=infrastructure>Infrastructure<a hidden class=anchor aria-hidden=true href=#infrastructure>#</a></h3><p>As mentioned in the diagram above, this is the layer where database communication usually happens. It&rsquo;s also commonly
known as the <em>Data Access</em> or <em>Persistence</em> layer. I&rsquo;m calling it <em>Infrastructure</em> because it can be used for more than
just persistence.</p><p>When used for data access, this layer usually consists of database entities and repositories. Here&rsquo;s an example in
Kotlin, using JPA annotations for object-relational mapping (ORM) and Spring Data&rsquo;s <code>CrudRepository</code> to generate a
repository implementation:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Entity
</span></span><span style=display:flex><span><span style=color:#fc5fa3>data</span> <span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>TodoList</span>(
</span></span><span style=display:flex><span>    @Id <span style=color:#fc5fa3>val</span> id: UUID,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> name: String
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    @OneToMany(mappedBy = <span style=color:#fc6a5d>&#34;todoList&#34;</span>, cascade = [<span style=color:#5dd8ff>CascadeType</span>.ALL])
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>val</span> items: MutableList&lt;TodoItem&gt; = mutableListOf()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@Entity
</span></span><span style=display:flex><span><span style=color:#fc5fa3>data</span> <span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>TodoItem</span>(
</span></span><span style=display:flex><span>    @Id <span style=color:#fc5fa3>val</span> id: UUID,
</span></span><span style=display:flex><span>    @ManyToOne
</span></span><span style=display:flex><span>    @JoinColumn(name = <span style=color:#fc6a5d>&#34;todolist_id&#34;</span>, nullable = <span style=color:#fc5fa3>false</span>)
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>val</span> todoList: TodoList,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> title: String,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> dueDate: LocalDateTime? = <span style=color:#fc5fa3>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> done: Boolean = <span style=color:#fc5fa3>false</span>,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@Repository
</span></span><span style=display:flex><span><span style=color:#fc5fa3>interface</span> <span style=color:#5dd8ff>TodoListRepository</span> : CrudRepository&lt;TodoList, UUID&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@Repository
</span></span><span style=display:flex><span><span style=color:#fc5fa3>interface</span> <span style=color:#5dd8ff>TodoItemRepository</span> : CrudRepository&lt;TodoItem, UUID&gt; {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>findByTodoListId</span>(id: UUID): List&lt;TodoItem&gt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=business>Business<a hidden class=anchor aria-hidden=true href=#business>#</a></h3><p>This layer contains the business logic of the application. Its responsibility is to make sure that business rules are
enforced in the application. It usually consists of services that perform a certain task, using repositories and
entities from the <em>Infrastructure</em> layer.</p><p>Here&rsquo;s a simple service that can create and remove todo lists (again, in Kotlin):</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>TodoListService</span>(<span style=color:#fc5fa3>val</span> repository: TodoListRepository) {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>createTodoList</span>(name: String): TodoList {
</span></span><span style=display:flex><span>        require(name.isNotBlank()) { <span style=color:#fc6a5d>&#34;Name cannot be blank&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>val</span> todoList = TodoList(<span style=color:#5dd8ff>UUID</span>.randomUUID(), name)
</span></span><span style=display:flex><span>        repository.save(todoList)
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>return</span> todoList
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>removeTodoList</span>(todoListToRemove: TodoList) {
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>if</span> (todoListToRemove.items.any { !<span style=color:#fc5fa3>it</span>.done }) {
</span></span><span style=display:flex><span>            <span style=color:#fc5fa3>throw</span> TodoListNotRemovableException()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        repository.delete(todoListToRemove)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a common pattern in these services. They check some business rules and if everything is okay, an action is
performed. In this example, the business rules are that a todo list must have a name and that a todo list may only be
deleted if all its todo items are done.</p><p>Here&rsquo;s an example that creates a new todo item:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>TodoItemService</span> {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>create</span>(id: UUID, description: String, dueDate: LocalDateTime?): TodoItem {
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>if</span> (dueDate != <span style=color:#fc5fa3>null</span> &amp;&amp; dueDate.isBefore(<span style=color:#5dd8ff>LocalDateTime</span>.now()))
</span></span><span style=display:flex><span>            <span style=color:#fc5fa3>throw</span> InvalidDueDateException()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>val</span> todoList = todoListRepository.findById(id).orElseThrow { TodoListNotFoundException() }
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>val</span> todoItem = TodoItem(id, todoList, description, dueDate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        todoList.items.add(todoItem)
</span></span><span style=display:flex><span>        todoListRepository.save(todoList)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>return</span> todoItem
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this example, besides input validation, we also ensure that we don&rsquo;t try to add a todo item to a list that does not
exist.</p><h3 id=presentation>Presentation<a hidden class=anchor aria-hidden=true href=#presentation>#</a></h3><p>In the variants mentioned earlier, the <em>Presentation</em> layer contains presentation and application logic. Alternatively,
presentation and application logic can be assigned to separate layers. It contains functionality that is used by end
users and uses the <em>Business</em> layer to validate and execute actions that users request. In a backend application that
exposes a REST API (for example for a frontend or external systems), this layer contains REST controllers.</p><p>Here&rsquo;s an example of a REST controller, using annotations from Spring Web:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@RestController
</span></span><span style=display:flex><span>@RequestMapping(<span style=color:#fc6a5d>&#34;/api/v1/todo/list&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>TodoListResource</span>(<span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>val</span> todoListService: TodoListService) {
</span></span><span style=display:flex><span>    @PostMapping
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>create</span>(@RequestParam name: String): ResponseEntity&lt;TodoListRestModel&gt; {
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>val</span> todoList = todoListService.createTodoList(name)
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>return</span> <span style=color:#5dd8ff>ResponseEntity</span>.status(<span style=color:#5dd8ff>HttpStatus</span>.CREATED)
</span></span><span style=display:flex><span>            .body(<span style=color:#5dd8ff>TodoListRestModel</span>.from(todoList))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <em>Business</em> layer is used to create and store the new todo item. The controller makes sure that a HTTP response is
returned, containing the newly created todo item.</p><h2 id=code-review>Code review<a hidden class=anchor aria-hidden=true href=#code-review>#</a></h2><p>These code examples are pretty simple and straightforward. That&rsquo;s because the problem domain and the associated business
rules are simple. You could argue that this code is perfectly fine for such a simple application, and I would agree.</p><p>Still, I&rsquo;d like to review this code with one important question in mind: <strong>Does it scale?</strong> Features will be added and
existing features will be expanded. Systems grow bigger and more complicated, and so does the code. Ideally, we want our
code to be designed in such a way that it stays maintainable while the system grows.</p><h3 id=duplication>Duplication<a hidden class=anchor aria-hidden=true href=#duplication>#</a></h3><p>While not directly obvious in the code above, we can see that we&rsquo;re setting ourselves up for code duplication. For
example, let&rsquo;s expand our <code>TodoListService</code> with the ability to rename an existing todo list:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>createTodoList</span>(name: String): TodoList {
</span></span><span style=display:flex><span>    require(name.isNotBlank()) { <span style=color:#fc6a5d>&#34;Name cannot be blank&#34;</span> }
</span></span><span style=display:flex><span>    <span style=color:#6c7986>// ...
</span></span></span><span style=display:flex><span><span style=color:#6c7986></span>    <span style=color:#fc5fa3>return</span> todoList
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>renameTodoList</span>(id: UUID, name: String) {
</span></span><span style=display:flex><span>    require(name.isNotBlank()) { <span style=color:#fc6a5d>&#34;Name cannot be blank&#34;</span> }
</span></span><span style=display:flex><span>    <span style=color:#6c7986>// ...
</span></span></span><span style=display:flex><span><span style=color:#6c7986></span>}
</span></span></code></pre></div><p>Now we have two functions that accept a name for a todo list. Obviously, a <code>String</code> can be blank, which we don&rsquo;t want,
so every time we use a <code>String</code> for accepting the name of a todo list, we need to check if that <code>String</code> contains a
valid name.</p><p>This problem arises when parameter types accept more values than the domain we&rsquo;re implementing allows for. If that&rsquo;s the
case, we need input validation to make sure our function is not used in an invalid way. This is an anti-pattern,
called <a href=https://refactoring.guru/smells/primitive-obsession>Primitive Obsession</a>. Be aware that this isn&rsquo;t limited to
the usage of primitives. In general, when we use overly permissive parameter types, we likely need input validation.</p><h3 id=public-mutable-state>Public mutable state<a hidden class=anchor aria-hidden=true href=#public-mutable-state>#</a></h3><p>Some of the state of entities in the <em>Infrastructure</em> layer can be changed by everyone. Take <code>TodoItem</code> for example:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Entity
</span></span><span style=display:flex><span><span style=color:#fc5fa3>data</span> <span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>TodoItem</span>(
</span></span><span style=display:flex><span>    @Id <span style=color:#fc5fa3>val</span> id: UUID,
</span></span><span style=display:flex><span>    @ManyToOne
</span></span><span style=display:flex><span>    @JoinColumn(name = <span style=color:#fc6a5d>&#34;todolist_id&#34;</span>, nullable = <span style=color:#fc5fa3>false</span>)
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>val</span> todoList: TodoList,
</span></span><span style=display:flex;background-color:#353539><span>    <span style=color:#fc5fa3>var</span> title: String,
</span></span><span style=display:flex;background-color:#353539><span>    <span style=color:#fc5fa3>var</span> dueDate: LocalDateTime? = <span style=color:#fc5fa3>null</span>,
</span></span><span style=display:flex;background-color:#353539><span>    <span style=color:#fc5fa3>var</span> done: Boolean = <span style=color:#fc5fa3>false</span>,
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>The fields <code>title</code>, <code>dueDate</code> and <code>done</code> have a public setter. This means it&rsquo;s very easy to write code that violates
business rules that are normally enforced by the <em>Business</em> layer. For example, we can easily introduce code that
changes a todo item to have an empty <code>title</code> or creates a new todo item with a <code>dueDate</code> in the past.</p><p>This is an anti-pattern known as <a href=https://refactoring.guru/smells/inappropriate-intimacy>Inappropriate Intimacy</a> or
<a href=https://en.wikipedia.org/wiki/Object_orgy>Object Orgy</a>.</p><h3 id=lack-of-encapsulation>Lack of encapsulation<a hidden class=anchor aria-hidden=true href=#lack-of-encapsulation>#</a></h3><p>The issue of public mutable state is a consequence of another design issue: Data and business logic are separated
between different classes. Data is modeled as entities, services make sure that the data conforms to the business rules.
The entities shown here are basically Data Transfer Objects (DTO&rsquo;s). They tell the Object-Relational Mapper (ORM) what
tables exist, which columns these tables consist of, et cetera.</p><p>These DTO&rsquo;s are used thoughout the entire code base. While the <em>Business</em> layer should be enforcing business rules, it&rsquo;s
very easy to violate business rules by changing DTO&rsquo;s in a REST controller, for example.</p><p>We&rsquo;re using an object-oriented (OO) language, but by designing our code like this we don&rsquo;t benefit from one of the
main strengths of OO, which is that data and the associated behaviour are <strong>encapsulated</strong> in one class. This makes our
code more error-prone than it needs to be.</p><h3 id=theres-a-bug>There&rsquo;s a bug!<a hidden class=anchor aria-hidden=true href=#theres-a-bug>#</a></h3><p>Maybe you already spotted it, there&rsquo;s a bug in <code>TodoItemService</code>. Can you find it?</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>create</span>(id: UUID, description: String, dueDate: LocalDateTime?): TodoItem {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>if</span> (dueDate != <span style=color:#fc5fa3>null</span> &amp;&amp; dueDate.isBefore(<span style=color:#5dd8ff>LocalDateTime</span>.now()))
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>throw</span> InvalidDueDateException()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>val</span> todoList = todoListRepository.findById(id).orElseThrow { TodoListNotFoundException() }
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>val</span> todoItem = TodoItem(id, todoList, description, dueDate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    todoList.items.add(todoItem)
</span></span><span style=display:flex><span>    todoListRepository.save(todoList)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>return</span> todoItem
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;ve shown this code in several talks I&rsquo;ve given, asking the participants to spot the bug. From my limited &ldquo;testing&rdquo; it
seems that the bug is surprisingly hard to find just by looking at the code.</p><p>Now, where&rsquo;s the bug? It&rsquo;s in this line:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>val</span> todoItem = TodoItem(id, todoList, description, dueDate)
</span></span></code></pre></div><p>The <code>id</code> that is passed to the constructor is the <code>id</code> of the containing <code>TodoList</code>! Let&rsquo;s assume the database table for
todo items has a proper primary key or a unique constraint. If that&rsquo;s the case, this code will fail as soon as we try to
add a second <code>TodoItem</code> to a <code>TodoList</code>, because a duplicate key will be inserted.</p><p>This is another example of Primitive Obsession. While <code>UUID</code> isn&rsquo;t a primitive type in the strict sense of the word, it
<em>is</em> a type that doesn&rsquo;t tell us anything about what kind of ID it actually represents. When we see just a <code>UUID</code>, it
can be hard to determine if it&rsquo;s the ID of a todo list, a todo item, or something entirely unrelated to the domain.</p><p><em>Fun fact</em>: This is a bug that I accidentally introduced when I was preparing this code for a talk. I decided to include
it in the talk as an example of how Primitive Obsession can easily lead to bugs that can be hard to find.</p><h2 id=smells>Smells<a hidden class=anchor aria-hidden=true href=#smells>#</a></h2><p>To summarize, in these code examples we have identified a couple of code smells:</p><ul><li><strong>Primitive Obsession</strong> &ndash; By using primitives or other overly permissive types, we need to duplicate input
validation.
Also, it&rsquo;s very easy to introduce bugs when multiple domain concepts are implemented using the same primitive type.</li><li><strong>Inappropriate Intimacy</strong> &ndash; Unrestricted write access to the state of an object can easily lead to violation of
business rules.</li><li><strong>Lack of encapsulation</strong> &ndash; Data and behaviour are separated into different classes.</li></ul><h2 id=principles>Principles<a hidden class=anchor aria-hidden=true href=#principles>#</a></h2><p>One way we can address the issues we found is by <strong>designing better types</strong>. In this chapter I&rsquo;d like to provide some
high-level principles and practices to help in designing better types. In future installments, we&rsquo;ll explore these more
in-depth.</p><p>I&rsquo;d like to mention two principles that I think are fundamental to designing with types. The principles are:</p><ul><li>Illegal states should be unrepresentable</li><li>State changes should be encapsulated</li></ul><h3 id=illegal-states-should-be-unrepresentable>Illegal states should be unrepresentable <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup><a hidden class=anchor aria-hidden=true href=#illegal-states-should-be-unrepresentable>#</a></h3><p>When writing code, the very first feedback we get about our code is from the compiler. This is the shortest possible
feedback loop we can have.</p><p>For example, when we try to assign a string to an integer variable, the compiler will immediately complain.</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>val</span> i: Int = <span style=color:#fc6a5d>&#34;Hello World!&#34;</span> <span style=color:#6c7986>// &lt;-- Compiler error
</span></span></span></code></pre></div><p>So the idea behind this principle is that in order to make our feedback loop as short as possible, we <strong>prefer
compile-time validation over runtime validation</strong>. We do this by designing types in such a way that it is <strong>impossible</strong>
to write <strong>compiling code</strong> that introduces an illegal state.</p><h3 id=state-changes-should-be-encapsulated>State changes should be encapsulated<a hidden class=anchor aria-hidden=true href=#state-changes-should-be-encapsulated>#</a></h3><p>Whenever we&rsquo;re using an object, we should be confident that the state of that object is valid. It&rsquo;s hard to be confident
about this when the state of an object is freely mutable by everyone. This is why we use <strong>encapsulation</strong> in OO.</p><p>So this principle means that we should make each class <strong>exclusively</strong> responsible for enforcing <strong>its own</strong> invariants.
This implies that each class should have <strong>exclusive control</strong> over its own state changes.</p><h2 id=principles-in-practice>Principles in practice<a hidden class=anchor aria-hidden=true href=#principles-in-practice>#</a></h2><p>So how do we put these principles into practice? Let&rsquo;s look at two simple examples.</p><h3 id=value-object-pattern>Value Object pattern<a hidden class=anchor aria-hidden=true href=#value-object-pattern>#</a></h3><p>This is such a simple design pattern, but it&rsquo;s oh so powerful! A value object represents one single value. This can be a
complex value consisting of multiple fields (i.e. amount and currency for money).</p><p>A value object must conform to the following rules:</p><ul><li>It is immutable</li><li>It is self-validating</li><li>The identity of the object is the value itself</li></ul><p>Let&rsquo;s look at two examples:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>data</span> <span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Name</span>(<span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>val</span> value: String) {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>init</span> {
</span></span><span style=display:flex><span>        require(<span style=color:#fc5fa3>value</span>.isNotBlank()) { <span style=color:#fc6a5d>&#34;Name cannot be blank&#34;</span> }
</span></span><span style=display:flex><span>        require(<span style=color:#fc5fa3>value</span>.lines().size == <span style=color:#d0bf69>1</span>) { <span style=color:#fc6a5d>&#34;Name must have exactly one line&#34;</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fc5fa3>data</span> <span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Description</span>(<span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>val</span> value: String) {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>init</span> {
</span></span><span style=display:flex><span>        require(<span style=color:#fc5fa3>value</span>.isNotBlank()) { <span style=color:#fc6a5d>&#34;Description cannot be blank&#34;</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we have two value objects, <code>Name</code> and <code>Description</code>. Both classes encapsulate an immutable value. Both classes make
sure that no invalid value is accepted. This is arguably the simplest possible example of encapsulation, but there are
profound consequences:</p><ul><li>Functions that accept a <code>Name</code> and/or a <code>Description</code> as a parameter don&rsquo;t need input validation for these parameters,
because that&rsquo;s what the constructors have already done. We can safely assume that the arguments are valid.</li><li>We write fewer tests, because if we don&rsquo;t need input validation, we don&rsquo;t need to unit tests input validation.</li><li>We can&rsquo;t confuse parameters. The following code does not compile, because we cannot pass a <code>Description</code> when a <code>Name</code>
is expected.<div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>TodoList</span>(<span style=color:#fc5fa3>val</span> id: TodoListID, name: Name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>main</span>() {
</span></span><span style=display:flex;background-color:#353539><span>    <span style=color:#fc5fa3>val</span> list = TodoList(<span style=color:#5dd8ff>TodoListID</span>.create(), Description(<span style=color:#fc6a5d>&#34;Description</span><span style=color:#fc6a5d>\n</span><span style=color:#fc6a5d>with multiple lines&#34;</span>)) <span style=color:#6c7986>// &lt;-- Compiler error
</span></span></span><span style=display:flex><span><span style=color:#6c7986></span>    <span style=color:#6c7986>// ...
</span></span></span><span style=display:flex><span><span style=color:#6c7986></span>}
</span></span></code></pre></div></li></ul><p>So here we see both principles in practice. We make illegal states unrepresentable because we cannot confuse values with
different domains. The values in the value objects are encapsulated and guaranteed to be valid, which simplifies our
code by eliminating the need for duplicated input validation.</p><h3 id=encapsulation-using-sum-types>Encapsulation using sum types<a hidden class=anchor aria-hidden=true href=#encapsulation-using-sum-types>#</a></h3><p>Here is a slightly more advanced example using a sum type:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>sealed</span> <span style=color:#fc5fa3>interface</span> <span style=color:#5dd8ff>TodoItem</span> {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>val</span> id: TodoItemID
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>val</span> description: Description
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>data</span> <span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Todo</span>(<span style=color:#fc5fa3>override</span> <span style=color:#fc5fa3>val</span> id: TodoItemID, <span style=color:#fc5fa3>override</span> <span style=color:#fc5fa3>val</span> description: Description) : TodoItem {
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>updateDescription</span>(newDescription: Description) = <span style=color:#fc5fa3>this</span>.copy(description = newDescription)
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>markAsDone</span>() = Done(id, description)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>data</span> <span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Done</span>(<span style=color:#fc5fa3>override</span> <span style=color:#fc5fa3>val</span> id: TodoItemID, <span style=color:#fc5fa3>override</span> <span style=color:#fc5fa3>val</span> description: Description) : TodoItem
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this example, we model <code>TodoItem</code> as a value object. The states (<code>todo</code> and <code>done</code>) of a todo item are modeled as
implementations of the <code>TodoItem</code> interface. The signatures of these types reveal that the description of a todo item in
the <code>todo</code> state can be changed. Todo items that are <code>done</code> cannot be changed at all<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>This is another way we can make illegal states unrepresentable using types. In fact, we take it a step further because
thanks to the sum type, we also make illegal state <strong>changes</strong> unrepresentable. The following code does not compile:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>val</span> item: TodoItem = <span style=color:#5dd8ff>TodoItem</span>.Done(<span style=color:#5dd8ff>TodoItemID</span>.create(), Description(<span style=color:#fc6a5d>&#34;Do the laundry&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#fc5fa3>val</span> changed: TodoItem =
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>when</span> (item) {
</span></span><span style=display:flex;background-color:#353539><span>        <span style=color:#fc5fa3>is</span> <span style=color:#5dd8ff>TodoItem</span>.Done -&gt; item.updateDescription(Description(<span style=color:#fc6a5d>&#34;Do the dishes&#34;</span>)) <span style=color:#6c7986>// &lt;-- Compiler error
</span></span></span><span style=display:flex><span><span style=color:#6c7986></span>        <span style=color:#fc5fa3>is</span> <span style=color:#5dd8ff>TodoItem</span>.Todo -&gt; item
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>The sum type forces us to check the state of the todo item, before attempting to do anything with it. If we don&rsquo;t, the
code simply won&rsquo;t compile. Code that tries to change the description of a <code>done</code> todo item also doesn&rsquo;t compile.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>A lot of the code I&rsquo;ve seen and written during my career suffers to some degree from the problems mentioned in this
article. As said, in simple, small systems there&rsquo;s little harm in having some Primitive Obsession or lack of
encapsulation. In such cases adding a lot of types can feel like overengineering. This is fine, as long as you are aware
that the antipatterns can become problematic when the system grows.</p><p>By designing better types, we can make our code <strong>safer</strong> to use and easier to understand by explicitly <strong>revealing
intent</strong>. In this article we&rsquo;ve seen two simple examples of this.</p><p>Next up, we&rsquo;ll talk some more about <strong>safety</strong> and <strong>revealing intent</strong> and we&rsquo;ll look at more examples of using types
to our advantage.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This phrase was coined
by <a href=https://blog.janestreet.com/effective-ml-revisited/>Yaron Minsky</a>. <a href=https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/>Scott Wlaschin</a>
wrote a very nice article about this, as part of his article series on designing with types using F#.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>For the Kotlin-savvy among you: Yes, I know about <code>copy</code> 😄. We&rsquo;ll address that in a future installment of this
series.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://dirkgroot.nl/tags/design/>Design</a></li><li><a href=https://dirkgroot.nl/tags/type-safety/>Type Safety</a></li><li><a href=https://dirkgroot.nl/tags/java/>Java</a></li><li><a href=https://dirkgroot.nl/tags/kotlin/>Kotlin</a></li><li><a href=https://dirkgroot.nl/tags/architecture/>Architecture</a></li><li><a href=https://dirkgroot.nl/tags/oo/>OO</a></li></ul><nav class=paginav><a class=next href=https://dirkgroot.nl/posts/series/designing-with-types/01-intro/><span class=title>Next »</span><br><span>Designing with types #01: Introduction</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://dirkgroot.nl/>Dirk Groot</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><footer class=dg-extended-footer><div class=social-icons><a href=https://github.com/dirkgroot target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://www.linkedin.com/in/dirkgroot77 target=_blank rel="noopener noreferrer me" title=Linkedin><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a><a href=https://x.com/dirk__groot target=_blank rel="noopener noreferrer me" title=X><svg viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>