<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Designing with types #03: Safety and Intent | Dirk Groot</title><meta name=keywords content="design,type safety,java,kotlin,OO"><meta name=description content="
    In the previous installment of this series, we concluded that we can write code that is safe and that reveals
intent by making illegal states unrepresentable and by encapsulating state changes. Today, we&rsquo;ll try to come up with
proper definitions of safety and revealing intent. Also, we&rsquo;ll take a look at more examples of applying these principles
in practice.
"><meta name=author content="Dirk Groot"><link rel=canonical href=https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/><link crossorigin=anonymous href=/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://dirkgroot.nl/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dirkgroot.nl/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dirkgroot.nl/favicon-32x32.png><link rel=apple-touch-icon href=https://dirkgroot.nl/apple-touch-icon.png><link rel=mask-icon href=https://dirkgroot.nl/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=/css/theme-overrides.css><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><script>!function(e,t){var n,s,o,i;t.__SV||(window.posthog=t,t._i=[],t.init=function(a,r,c){function d(e,t){var n=t.split(".");2==n.length&&(e=e[n[0]],t=n[1]),e[t]=function(){e.push([t].concat(Array.prototype.slice.call(arguments,0)))}}(n=e.createElement("script")).type="text/javascript",n.crossOrigin="anonymous",n.async=!0,n.src=r.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(i=e.getElementsByTagName("script")[0]).parentNode.insertBefore(n,i);var l=t;for(0[0]!==c?l=t[c]=[]:c="posthog",l.people=l.people||[],l.toString=function(e){var t="posthog";return"posthog"!==c&&(t+="."+c),e||(t+=" (stub)"),t},l.people.toString=function(){return l.toString(1)+".people (stub)"},o="init be ys Ss me gs ws capture Ne calculateEventProperties xs register register_once register_for_session unregister unregister_for_session Rs getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty Is ks createPersonProfile Ps bs opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing clear_opt_in_out_capturing $s debug Es getPageViewId captureTraceFeedback captureTraceMetric".split(" "),s=0;s<o.length;s++)d(l,o[s]);t._i.push([a,r,c])},t.__SV=1)}(document,window.posthog||[]),posthog.init("phc_C7a3Twl8BDeaz7aHzeDLGuJDgYNfanH69WV2E6PY5wL",{api_host:"https://eu.i.posthog.com",person_profiles:"identified_only"})</script><meta property="og:url" content="https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/"><meta property="og:site_name" content="Dirk Groot"><meta property="og:title" content="Designing with types #03: Safety and Intent"><meta property="og:description" content=" In the previous installment of this series, we concluded that we can write code that is safe and that reveals intent by making illegal states unrepresentable and by encapsulating state changes. Today, we’ll try to come up with proper definitions of safety and revealing intent. Also, we’ll take a look at more examples of applying these principles in practice. "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-09T09:38:34+00:00"><meta property="article:modified_time" content="2025-07-09T09:38:34+00:00"><meta property="article:tag" content="Design"><meta property="article:tag" content="Type Safety"><meta property="article:tag" content="Java"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="OO"><meta property="og:image" content="https://dirkgroot.nl/cover.png"><meta property="og:see_also" content="https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/"><meta property="og:see_also" content="https://dirkgroot.nl/posts/series/designing-with-types/01-intro/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dirkgroot.nl/cover.png"><meta name=twitter:title content="Designing with types #03: Safety and Intent"><meta name=twitter:description content="
    In the previous installment of this series, we concluded that we can write code that is safe and that reveals
intent by making illegal states unrepresentable and by encapsulating state changes. Today, we&rsquo;ll try to come up with
proper definitions of safety and revealing intent. Also, we&rsquo;ll take a look at more examples of applying these principles
in practice.
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dirkgroot.nl/posts/"},{"@type":"ListItem","position":2,"name":"Designing with types #03: Safety and Intent","item":"https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Designing with types #03: Safety and Intent","name":"Designing with types #03: Safety and Intent","description":" In the previous installment of this series, we concluded that we can write code that is safe and that reveals intent by making illegal states unrepresentable and by encapsulating state changes. Today, we\u0026rsquo;ll try to come up with proper definitions of safety and revealing intent. Also, we\u0026rsquo;ll take a look at more examples of applying these principles in practice. ","keywords":["design","type safety","java","kotlin","OO"],"articleBody":" In the previous installment of this series, we concluded that we can write code that is safe and that reveals intent by making illegal states unrepresentable and by encapsulating state changes. Today, we’ll try to come up with proper definitions of safety and revealing intent. Also, we’ll take a look at more examples of applying these principles in practice. Safety What does safety mean in the context of software development in general and designing types in particular? Here’s my attempt at a “formal” definition:\nWe consider an API to be safe if and only if everything that’s public can be used freely, without the risk of introducing an illegal state. With this definition I’m trying to stay as language agnostic as possible. Reason for this is that the concept of safety can be applied (to some extent) to every programming language and every paradigm.\nIn this series, we’re focusing mainly on strong-typed, object-oriented languages like Kotlin and Java. In those languages everything that’s public is either a public class, a public method, a public field or (in Kotlin) a public top-level function. To be more specific, this definition applies to everything that causes a state change. Things like read-only fields or pure functions are always safe according to this definition, because those things don’t modify anything.\nSo what does this mean in practice for things that do modify something? Let’s look at each case individually.\nPublic mutable fields can only be freely mutable if there exist zero situations where a possible value of such a field can be considered invalid. If this is not the case, a field cannot be publicly mutable according to this definition. Public methods and top-level functions that change state may never change that state to something invalid. According to this definition, such methods or functions must either: change the state to something valid; throw an exception; do nothing; or return a value that indicates a failure. Revealing intent Code is written once, but it’s read many times. Therefore we want the code to be easy to understand. For this article series, I’ll use a pretty narrow definition of revealing intent:\nCode that reveals intent is explicit about what it does, what it expects and what it results in. I don’t think this definition needs much of an explanation. It doesn’t just apply to code. Take a typical use case template for example. Such a template will typically have room for us to document the goal, the preconditions and the postconditions. In order to properly understand a piece of functionality, this is what we typically need to know, regardless of whether we’re reading code or a use case.\nThis series is about designing with types, so here we’ll be focusing on revealing intent using types. As we’ll see, types are a very powerful way of revealing intent. This is because types allow us to give important concepts a proper name and because by defining types, we can leverage the power of the compiler to enforce intended usage.\nExamples With the principles from the previous article in mind, let’s look at some practical examples. Every example will start by reviewing a piece of code, evaluating whether it’s safe and if it reveals intent.\nProperties Code review Let’s look at this Customer class:\nclass Customer( var id: Long, var name: String, var emailAddress: String, ) There’s no context in this example, but it’s not hard to see that this code probably isn’t safe:\nThe id field is publicly mutable, but it’s generally not recommended to change the primary key of an entity. The id field is a plain Long, but negative values are probably not allowed. The name and emailAddress fields are plain Strings, but it’s highly unlikely that every possible String is a valid value for these fields. Let’s assume that in this case, it’s safe that name and emailAddress are publicly mutable.\nThe code does reveal intent to some degree, but it’s the bare minimum. It uses helpful names for the properties, but the property types don’t reveal any intent at all. The constraints for the id, name and emailAddress are not obvious and it’s not clear where we can find those constraints.\nRefactoring The first and most obvious thing we can do to improve the safety of this code, is to make id immutable. By doing this, we eliminate one way to introduce an illegal state.\nclass Customer( val id: Long, var name: String, var emailAddress: String, ) We can make id, name and emailAddress safe by introducing Value Objects.\nclass Customer( val id: CustomerID, var name: CustomerName, var emailAddress: EmailAddress, ) data class CustomerID(private val value: Long) { init { require(value \u003e= 0L) } } data class CustomerName(private val value: String) { init { require(value.isNotBlank()) } } data class EmailAddress(private val value: String) { init { require(isValidEmailAddress(value)) // let's pretend we have this function available somewhere 😉 } } Just like in the previous article, we can see the power of the Value Object pattern. With one refactoring, we made two improvements:\nThe code is now safe. There is simply no way we can write compiling code that introduces an illegal state. The code will either not compile or we’ll get an exception for trying to introduce an illegal state. We cannot accidentally swap name and emailAddress, because that code won’t compile: val customer = Customer(id = CustomerID(0), name = EmailAddress(\"name@example.com\"), emailAddress = CustomerName(\"John Johnsson\")) We cannot give id an invalid value, because that will throw an exception: val id = CustomerID(-1) The code reveals intent much more clearly. The constructor arguments of Customer all have a type with a proper name, which makes it obvious that acceptable values for those arguments belong to a certain domain. It’s also easy to find the constraints for id, name and emailAddress. We simply use our IDE to navigate to the type definitions of the corresponding Value Objects and we’ll have all the information we need. Simple business rules Code review Here’s an Order class:\nclass Order( val id: OrderID, val customerId: CustomerID, var status: OrderStatus, var paymentId: PaymentID?, ) Here’s a service that makes sure that orders that have not been payed cannot be completed:\nclass OrderService { fun completeOrder(order: Order) { if (order.paymentId != null) order.status = OrderStatus.COMPLETED } } The Order class uses Value Objects and id and customerId are immutable, so it’s pretty safe, except that status is publicly mutable. We can easily create an order with status OrderStatus.COMPLETED while it has not been payed. We just circumvent OrderService and call the Order constructor directly:\n// This code compiles and throws no exceptions val order = Order(OrderID(1), CustomerID(2), OrderStatus.COMPLETED, null) The code above communicates intent via OrderService, but Order and OrderService are different classes which are usually defined in different source files, which could belong to different packages. It would be clearer if the data and the business rule were close together.\nRefactoring We can improve this by introducing more encapsulation. We do this by merging OrderService and Order, so we can make the setters for status and paymentId private.\nclass Order(val id: OrderID, val customerId: CustomerID) { var status: OrderStatus = OrderStatus.PENDING private set var paymentId: PaymentID? = null private set fun complete() { if (paymentId != null) status = OrderStatus.COMPLETED else throw IllegalStateException(\"Cannot complete an order that has not been payed\") } } With this refactoring we made multiple improvements:\nThe code is now safe, because all state changes changes are encapsulated inside the Order class. This doesn’t compile, because of the private setter for status: val order = Order(OrderID(1), CustomerID(2)) order.status = OrderStatus.COMPLETED // \u003c- Compiler error And this raises an exception: val order = Order(OrderID(1), CustomerID(2)) order.complete() // \u003c- BOOM! Intent is clearer, because the data and the business rule are defined in one class instead of two. Intent is also more clear, because the Order constructor contains only fields that are relevant for creating an order in the initial state. All state changes are done using methods like complete (I omitted other methods for brevity). Statuses Code review Coming back to the Order class, let’s zoom in on the order status:\nclass Order { var status: OrderStatus = OrderStatus.PENDING private set } What can we say about such a small piece of code? Well, first of all it looks pretty safe, because the status field has a private setter. What else? Let’s look at how we would instantiate this class:\nval order = Order() We’ve lost some information compared to the class definition. From this constructor invocation alone, it’s not obvious what the status of the newly created order is. This is a limitation of constructors in general, because we can’t give constructors a descriptive name.\nRefactoring We can improve the communication of intent by introducing a factory method.\nclass Order(status: OrderStatus) { var status: OrderStatus = status private set companion object { fun createPending(): Order = Order(OrderStatus.PENDING) } } Now, we can instantiate a new Order using the createPending factory:\nval order = Order.createPending() This is clearly an improvement. By using the factory we are explicit about the state of a newly created Order. Unfortunately, there’s a downside: We now have a public constructor that accepts any OrderStatus. We have potentially introduced the same safety issue we addressed in the previous example.\nFortunately, the solution is simple. We’ll just make the constructor private:\nclass Order private constructor(status: OrderStatus) { var status: OrderStatus = status private set companion object { fun createPending(): Order = Order(OrderStatus.PENDING) } } Now, the design is safe again. There’s only one way to create a new Order, which is via the createPending factory.\nConclusion We identified two requirements and two design principles to help us write code that is robust and maintainable. The requirements are:\nWe should design API’s so that\nthey are always safe to use; they reveal intent. We can achieve this by using the design principles we discussed in the previous article:\nIllegal states should be unrepresentable. State changes should be encapsulated. We’ve seen various examples of how to put this into practice. Until now, the code examples we looked at were rather simple and straightforward. In the next installment we’ll conclude this series by looking at a few examples that are less straightforward.\n","wordCount":"1704","inLanguage":"en","image":"https://dirkgroot.nl/cover.png","datePublished":"2025-07-09T09:38:34Z","dateModified":"2025-07-09T09:38:34Z","author":{"@type":"Person","name":"Dirk Groot"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/"},"publisher":{"@type":"Organization","name":"Dirk Groot","logo":{"@type":"ImageObject","url":"https://dirkgroot.nl/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://dirkgroot.nl/ accesskey=h title="Dirk Groot (Alt + H)">Dirk Groot</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://dirkgroot.nl/ title=Blog><span>Blog</span></a></li><li><a href=https://dirkgroot.nl/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dirkgroot.nl/series/ title=Series><span>Series</span></a></li><li><a href=https://dirkgroot.nl/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://dirkgroot.nl/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://dirkgroot.nl/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dirkgroot.nl/>Home</a>&nbsp;»&nbsp;<a href=https://dirkgroot.nl/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Designing with types #03: Safety and Intent</h1><div class=post-meta><span title='2025-07-09 09:38:34 +0000 UTC'>July 9, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Dirk Groot</div></header><figure class=entry-cover><img loading=eager srcset='https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/cover_hu_37a083838b9d0f0e.png 360w,https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/cover_hu_ba39136623fd2965.png 480w,https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/cover_hu_573edbfb0af76dcf.png 720w,https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/cover_hu_33f709c66dae9469.png 1080w,https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/cover_hu_b6088b81861002ef.png 1500w,https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/cover.png 1584w' src=https://dirkgroot.nl/posts/series/designing-with-types/03-safety-and-intent/cover.png sizes="(min-width: 768px) 720px, 100vw" width=1584 height=300 alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#safety aria-label=Safety>Safety</a></li><li><a href=#revealing-intent aria-label="Revealing intent">Revealing intent</a></li><li><a href=#examples aria-label=Examples>Examples</a><ul><li><a href=#properties aria-label=Properties>Properties</a><ul><li><a href=#code-review aria-label="Code review">Code review</a></li><li><a href=#refactoring aria-label=Refactoring>Refactoring</a></li></ul></li><li><a href=#simple-business-rules aria-label="Simple business rules">Simple business rules</a><ul><li><a href=#code-review-1 aria-label="Code review">Code review</a></li><li><a href=#refactoring-1 aria-label=Refactoring>Refactoring</a></li></ul></li><li><a href=#statuses aria-label=Statuses>Statuses</a><ul><li><a href=#code-review-2 aria-label="Code review">Code review</a></li><li><a href=#refactoring-2 aria-label=Refactoring>Refactoring</a></li></ul></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><summary class=dg-summary>In the previous installment of this series, we concluded that we can write code that is <strong>safe</strong> and that <strong>reveals
intent</strong> by making illegal states unrepresentable and by encapsulating state changes. Today, we&rsquo;ll try to come up with
proper definitions of safety and revealing intent. Also, we&rsquo;ll take a look at more examples of applying these principles
in practice.</summary><h2 id=safety>Safety<a hidden class=anchor aria-hidden=true href=#safety>#</a></h2><p>What does <strong>safety</strong> mean in the context of software development in general and designing types in particular? Here&rsquo;s my
attempt at a &ldquo;formal&rdquo; definition:</p><summary class=dg-summary>We consider an API to be <strong>safe</strong> if and only if <strong>everything that&rsquo;s public</strong> can be used <strong>freely</strong>, without the risk
of introducing an illegal state.</summary><p>With this definition I&rsquo;m trying to stay as language agnostic as possible. Reason for this is that the concept of safety
can be applied (to some extent) to every programming language and every paradigm.</p><p>In this series, we&rsquo;re focusing mainly on strong-typed, object-oriented languages like Kotlin and Java. In those
languages <strong>everything that&rsquo;s public</strong> is either a public class, a public method, a public field or (in Kotlin) a public
top-level function. To be more specific, this definition applies to everything that causes a state change. Things like
read-only fields or pure functions are always safe according to this definition, because those things don&rsquo;t modify
anything.</p><p>So what does this mean in practice for things that do modify something? Let&rsquo;s look at each case individually.</p><ul><li><strong>Public mutable fields</strong> can only be freely mutable if there exist <strong>zero</strong> situations where a possible
value of such a field can be considered invalid. If this is not the case, a field cannot be publicly mutable according
to this definition.</li><li><strong>Public methods and top-level functions</strong> that change state may <strong>never</strong> change that state to something invalid.
According to this definition, such methods or functions must either:<ul><li>change the state to something valid;</li><li>throw an exception;</li><li>do nothing;</li><li>or return a value that indicates a failure.</li></ul></li></ul><h2 id=revealing-intent>Revealing intent<a hidden class=anchor aria-hidden=true href=#revealing-intent>#</a></h2><p>Code is written once, but it&rsquo;s read many times. Therefore we want the code to be easy to understand. For this article
series, I&rsquo;ll use a pretty narrow definition of revealing intent:</p><summary class=dg-summary>Code that reveals intent is <strong>explicit</strong> about what it <strong>does</strong>, what it <strong>expects</strong> and what it <strong>results</strong> in.</summary><p>I don&rsquo;t think this definition needs much of an explanation. It doesn&rsquo;t just apply to code. Take a
typical <a href=https://en.wikipedia.org/wiki/Use_case#Examples>use case template</a> for example. Such a template will typically
have room for us to document the goal, the preconditions and the postconditions. In order to properly understand a piece
of functionality, this is what we typically need to know, regardless of whether we&rsquo;re reading code or a use case.</p><p>This series is about designing with types, so here we&rsquo;ll be focusing on revealing intent using types. As we&rsquo;ll see,
types are a very powerful way of revealing intent. This is because types allow us to give important concepts a proper
<strong>name</strong> and because by defining types, we can leverage the <strong>power of the compiler</strong> to enforce intended usage.</p><h2 id=examples>Examples<a hidden class=anchor aria-hidden=true href=#examples>#</a></h2><p>With the principles from the <a href=../02-pitfalls-and-practices>previous article</a> in mind, let&rsquo;s look at some practical
examples. Every example will start by reviewing a piece of code, evaluating whether it&rsquo;s safe and if it reveals intent.</p><h3 id=properties>Properties<a hidden class=anchor aria-hidden=true href=#properties>#</a></h3><h4 id=code-review>Code review<a hidden class=anchor aria-hidden=true href=#code-review>#</a></h4><p>Let&rsquo;s look at this <code>Customer</code> class:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Customer</span>(
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> id: Long,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> name: String,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> emailAddress: String,
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>There&rsquo;s no context in this example, but it&rsquo;s not hard to see that this code probably isn&rsquo;t safe:</p><ul><li>The <code>id</code> field is publicly mutable, but it&rsquo;s generally not recommended to change the primary key of an entity.</li><li>The <code>id</code> field is a plain <code>Long</code>, but negative values are probably not allowed.</li><li>The <code>name</code> and <code>emailAddress</code> fields are plain <code>String</code>s, but it&rsquo;s highly unlikely that every possible <code>String</code>
is a valid value for these fields.</li></ul><p>Let&rsquo;s assume that in this case, it&rsquo;s safe that <code>name</code> and <code>emailAddress</code> are publicly mutable.</p><p>The code does reveal intent to some degree, but it&rsquo;s the bare minimum. It uses helpful names for the properties, but
the property types don&rsquo;t reveal any intent at all. The constraints for the <code>id</code>, <code>name</code> and <code>emailAddress</code> are not
obvious and it&rsquo;s not clear where we can find those constraints.</p><h4 id=refactoring>Refactoring<a hidden class=anchor aria-hidden=true href=#refactoring>#</a></h4><p>The first and most obvious thing we can do to improve the safety of this code, is to make <code>id</code> immutable. By doing this,
we eliminate one way to introduce an illegal state.</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Customer</span>(
</span></span><span style=display:flex;background-color:#353539><span>    <span style=color:#fc5fa3>val</span> id: Long,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> name: String,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> emailAddress: String,
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>We can make <code>id</code>, <code>name</code> and <code>emailAddress</code> safe by
introducing <a href=../02-pitfalls-and-practices#value-object-pattern>Value Objects</a>.</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Customer</span>(
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>val</span> id: CustomerID,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> name: CustomerName,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> emailAddress: EmailAddress,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fc5fa3>data</span> <span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>CustomerID</span>(<span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>val</span> value: Long) {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>init</span> {
</span></span><span style=display:flex><span>        require(<span style=color:#fc5fa3>value</span> &gt;= <span style=color:#d0bf69>0L</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fc5fa3>data</span> <span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>CustomerName</span>(<span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>val</span> value: String) {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>init</span> {
</span></span><span style=display:flex><span>        require(<span style=color:#fc5fa3>value</span>.isNotBlank())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fc5fa3>data</span> <span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>EmailAddress</span>(<span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>val</span> value: String) {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>init</span> {
</span></span><span style=display:flex><span>        require(isValidEmailAddress(<span style=color:#fc5fa3>value</span>)) <span style=color:#6c7986>// let&#39;s pretend we have this function available somewhere 😉
</span></span></span><span style=display:flex><span><span style=color:#6c7986></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Just like in the previous article, we can see the power of the Value Object pattern. With one refactoring, we made two
improvements:</p><ol><li>The code is now safe. There is simply no way we can write compiling code that introduces an illegal state. The
code will either not compile or we&rsquo;ll get an exception for trying to introduce an illegal state. We cannot
accidentally swap <code>name</code> and <code>emailAddress</code>, because that code won&rsquo;t compile:<div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>val</span> customer = Customer(id = CustomerID(<span style=color:#d0bf69>0</span>), name = EmailAddress(<span style=color:#fc6a5d>&#34;name@example.com&#34;</span>), emailAddress = CustomerName(<span style=color:#fc6a5d>&#34;John Johnsson&#34;</span>))
</span></span></code></pre></div>We cannot give <code>id</code> an invalid value, because that will throw an exception:<div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>val</span> id = CustomerID(-<span style=color:#d0bf69>1</span>)
</span></span></code></pre></div></li><li>The code reveals intent much more clearly. The constructor arguments of <code>Customer</code> all have a type with a proper
name, which makes it obvious that acceptable values for those arguments belong to a certain domain. It&rsquo;s also easy to
find the constraints for <code>id</code>, <code>name</code> and <code>emailAddress</code>. We simply use our IDE to navigate to the type definitions
of the corresponding Value Objects and we&rsquo;ll have all the information we need.</li></ol><h3 id=simple-business-rules>Simple business rules<a hidden class=anchor aria-hidden=true href=#simple-business-rules>#</a></h3><h4 id=code-review-1>Code review<a hidden class=anchor aria-hidden=true href=#code-review-1>#</a></h4><p>Here&rsquo;s an <code>Order</code> class:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Order</span>(
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>val</span> id: OrderID,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>val</span> customerId: CustomerID,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> status: OrderStatus,
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> paymentId: PaymentID?,
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Here&rsquo;s a service that makes sure that orders that have not been payed cannot be completed:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>OrderService</span> {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>completeOrder</span>(order: Order) {
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>if</span> (order.paymentId != <span style=color:#fc5fa3>null</span>)
</span></span><span style=display:flex><span>            order.status = <span style=color:#5dd8ff>OrderStatus</span>.COMPLETED
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Order</code> class uses Value Objects and <code>id</code> and <code>customerId</code> are immutable, so it&rsquo;s pretty safe, except that
<code>status</code> is publicly mutable. We can easily create an order with status <code>OrderStatus.COMPLETED</code> while it has not been
payed. We just circumvent <code>OrderService</code> and call the <code>Order</code> constructor directly:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6c7986>// This code compiles and throws no exceptions
</span></span></span><span style=display:flex><span><span style=color:#6c7986></span><span style=color:#fc5fa3>val</span> order = Order(OrderID(<span style=color:#d0bf69>1</span>), CustomerID(<span style=color:#d0bf69>2</span>), <span style=color:#5dd8ff>OrderStatus</span>.COMPLETED, <span style=color:#fc5fa3>null</span>)
</span></span></code></pre></div><p>The code above communicates intent via <code>OrderService</code>, but <code>Order</code> and <code>OrderService</code> are different classes which are
usually defined in different source files, which could belong to different packages. It would be clearer if the data and
the business rule were close together.</p><h4 id=refactoring-1>Refactoring<a hidden class=anchor aria-hidden=true href=#refactoring-1>#</a></h4><p>We can improve this by introducing more encapsulation. We do this by merging <code>OrderService</code> and <code>Order</code>, so we can make
the setters for <code>status</code> and <code>paymentId</code> private.</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Order</span>(<span style=color:#fc5fa3>val</span> id: OrderID, <span style=color:#fc5fa3>val</span> customerId: CustomerID) {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> status: OrderStatus = <span style=color:#5dd8ff>OrderStatus</span>.PENDING
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>set</span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> paymentId: PaymentID? = <span style=color:#fc5fa3>null</span>
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>set</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>complete</span>() {
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>if</span> (paymentId != <span style=color:#fc5fa3>null</span>)
</span></span><span style=display:flex><span>            status = <span style=color:#5dd8ff>OrderStatus</span>.COMPLETED
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>else</span>
</span></span><span style=display:flex><span>            <span style=color:#fc5fa3>throw</span> IllegalStateException(<span style=color:#fc6a5d>&#34;Cannot complete an order that has not been payed&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With this refactoring we made multiple improvements:</p><ul><li>The code is now safe, because all state changes changes are encapsulated inside the <code>Order</code> class. This doesn&rsquo;t
compile, because of the private setter for <code>status</code>:<div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>val</span> order = Order(OrderID(<span style=color:#d0bf69>1</span>), CustomerID(<span style=color:#d0bf69>2</span>))
</span></span><span style=display:flex;background-color:#353539><span>order.status = <span style=color:#5dd8ff>OrderStatus</span>.COMPLETED <span style=color:#6c7986>// &lt;- Compiler error
</span></span></span></code></pre></div>And this raises an exception:<div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>val</span> order = Order(OrderID(<span style=color:#d0bf69>1</span>), CustomerID(<span style=color:#d0bf69>2</span>))
</span></span><span style=display:flex;background-color:#353539><span>order.complete() <span style=color:#6c7986>// &lt;- BOOM!
</span></span></span></code></pre></div></li><li>Intent is clearer, because the data and the business rule are defined in one class instead of two.</li><li>Intent is also more clear, because the <code>Order</code> constructor contains only fields that are relevant for creating an
order in the initial state. All state changes are done using methods like <code>complete</code> (I omitted other methods for
brevity).</li></ul><h3 id=statuses>Statuses<a hidden class=anchor aria-hidden=true href=#statuses>#</a></h3><h4 id=code-review-2>Code review<a hidden class=anchor aria-hidden=true href=#code-review-2>#</a></h4><p>Coming back to the <code>Order</code> class, let&rsquo;s zoom in on the order status:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Order</span> {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> status: OrderStatus = <span style=color:#5dd8ff>OrderStatus</span>.PENDING
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>set</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What can we say about such a small piece of code? Well, first of all it looks pretty safe, because the <code>status</code> field
has a private setter. What else? Let&rsquo;s look at how we would instantiate this class:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>val</span> order = Order()
</span></span></code></pre></div><p>We&rsquo;ve lost some information compared to the class definition. From this constructor invocation alone, it&rsquo;s not obvious
what the status of the newly created order is. This is a limitation of constructors in general, because we can&rsquo;t give
constructors a descriptive name.</p><h4 id=refactoring-2>Refactoring<a hidden class=anchor aria-hidden=true href=#refactoring-2>#</a></h4><p>We can improve the communication of intent by introducing a factory method.</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Order</span>(status: OrderStatus) {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> status: OrderStatus = status
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>set</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>companion</span> <span style=color:#fc5fa3>object</span> {
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>createPending</span>(): Order = Order(<span style=color:#5dd8ff>OrderStatus</span>.PENDING)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, we can instantiate a new <code>Order</code> using the <code>createPending</code> factory:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fc5fa3>val</span> order = <span style=color:#5dd8ff>Order</span>.createPending()
</span></span></code></pre></div><p>This is clearly an improvement. By using the factory we are explicit about the state of a newly created <code>Order</code>.
Unfortunately, there&rsquo;s a downside: We now have a public constructor that accepts any <code>OrderStatus</code>. We have potentially
introduced the same safety issue we addressed in the previous example.</p><p>Fortunately, the solution is simple. We&rsquo;ll just make the constructor <code>private</code>:</p><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-kotlin data-lang=kotlin><span style=display:flex;background-color:#353539><span><span style=color:#fc5fa3>class</span> <span style=color:#5dd8ff>Order</span> <span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>constructor</span>(status: OrderStatus) {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>var</span> status: OrderStatus = status
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>private</span> <span style=color:#fc5fa3>set</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>companion</span> <span style=color:#fc5fa3>object</span> {
</span></span><span style=display:flex><span>        <span style=color:#fc5fa3>fun</span> <span style=color:#41a1c0>createPending</span>(): Order = Order(<span style=color:#5dd8ff>OrderStatus</span>.PENDING)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, the design is safe again. There&rsquo;s only one way to create a new <code>Order</code>, which is via the <code>createPending</code> factory.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>We identified two requirements and two design principles to help us write code that is robust and maintainable. The
requirements are:</p><summary class=dg-summary><p>We should design API&rsquo;s so that</p><ul><li>they are always <strong>safe</strong> to use;</li><li>they <strong>reveal intent</strong>.</li></ul></summary><p>We can achieve this by using the design principles we discussed in
the <a href=../02-pitfalls-and-practices#principles>previous article</a>:</p><summary class=dg-summary><ul><li>Illegal states should be unrepresentable.</li><li>State changes should be encapsulated.</li></ul></summary><p>We&rsquo;ve seen various examples of how to put this into practice. Until now, the code examples we looked at were rather
simple and straightforward. In the next installment we&rsquo;ll conclude this series by looking at a few examples that are
less straightforward.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dirkgroot.nl/tags/design/>Design</a></li><li><a href=https://dirkgroot.nl/tags/type-safety/>Type Safety</a></li><li><a href=https://dirkgroot.nl/tags/java/>Java</a></li><li><a href=https://dirkgroot.nl/tags/kotlin/>Kotlin</a></li><li><a href=https://dirkgroot.nl/tags/oo/>OO</a></li></ul><nav class=paginav><a class=next href=https://dirkgroot.nl/posts/series/designing-with-types/02-pitfalls-and-practices/><span class=title>Next »</span><br><span>Designing with types #02: Pitfalls and Practices</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://dirkgroot.nl/>Dirk Groot</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><footer class=dg-extended-footer><div class=social-icons><a href=https://github.com/dirkgroot target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://www.linkedin.com/in/dirkgroot77 target=_blank rel="noopener noreferrer me" title=Linkedin><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a><a href=https://x.com/dirk__groot target=_blank rel="noopener noreferrer me" title=X><svg viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>