<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Robot Worlds 4: End to end | Dirk Groot</title><meta name=keywords content="walking-skeleton,robot-worlds,kotlin,tdd,yagni"><meta name=description content="
    I feel like we&rsquo;re almost done with our walking skeleton. Today, I&rsquo;ll try to finish it.
"><meta name=author content="Dirk Groot"><link rel=canonical href=https://blog.dirkgroot.nl/posts/robot-worlds/04-end-to-end/><link crossorigin=anonymous href=/assets/css/stylesheet.b183800e2cfbb62c3bce2b2ba56cdb2dd33af76c75cf4550173d5dfebd7c68a6.css integrity="sha256-sYOADiz7tiw7zisrpWzbLdM692x1z0VQFz1d/r18aKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.dirkgroot.nl/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.dirkgroot.nl/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.dirkgroot.nl/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.dirkgroot.nl/apple-touch-icon.png><link rel=mask-icon href=https://blog.dirkgroot.nl/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=/css/theme-overrides.css><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-TBE6V39YXJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TBE6V39YXJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Robot Worlds 4: End to end"><meta property="og:description" content="
    I feel like we&rsquo;re almost done with our walking skeleton. Today, I&rsquo;ll try to finish it.
"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.dirkgroot.nl/posts/robot-worlds/04-end-to-end/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-25T16:20:22+00:00"><meta property="article:modified_time" content="2022-06-25T16:20:22+00:00"><meta property="og:see_also" content="https://blog.dirkgroot.nl/posts/robot-worlds/03-client/"><meta property="og:see_also" content="https://blog.dirkgroot.nl/posts/robot-worlds/02-communication/"><meta property="og:see_also" content="https://blog.dirkgroot.nl/posts/robot-worlds/01-walking-skeleton/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Robot Worlds 4: End to end"><meta name=twitter:description content="
    I feel like we&rsquo;re almost done with our walking skeleton. Today, I&rsquo;ll try to finish it.
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.dirkgroot.nl/posts/"},{"@type":"ListItem","position":3,"name":"Robot Worlds 4: End to end","item":"https://blog.dirkgroot.nl/posts/robot-worlds/04-end-to-end/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Robot Worlds 4: End to end","name":"Robot Worlds 4: End to end","description":" I feel like we\u0026rsquo;re almost done with our walking skeleton. Today, I\u0026rsquo;ll try to finish it. ","keywords":["walking-skeleton","robot-worlds","kotlin","tdd","yagni"],"articleBody":" I feel like we‚Äôre almost done with our walking skeleton. Today, I‚Äôll try to finish it. Recap Design so far It‚Äôs been a few days since I wrote the last article, so let‚Äôs take a moment to review our design so far. Currently, the game consists of two ‚Äúchunks‚Äù, or components: the client and the server.\nStep by step, we‚Äôve been working our way up the call stack, starting with World. In the previous post, we created SocketClient, which means we‚Äôre now able to send a JSON string to the server over TCP, and get a JSON string back as a reply.\nTerminology Before we move on, let‚Äôs look at the terminology we‚Äôre using. I‚Äôm seeing an inconsistency I‚Äôd like to address. Making a little diagram like this often helps to make these kinds of inconsistencies obvious. From this diagram, it‚Äôs quite obvious that we‚Äôre using four words, without making it obvious how these words are related to each other: message, request, command and result.\nAll of these words are actually used in the protocol specification. In my words, the spec says that the client sends a request message containing a command, and the server replies with a response message, containing a result. This structure is not visible in our design. Let‚Äôs try to make this more obvious.\nLet‚Äôs rename Request to RequestMesage, and CommandResult to ResponseMessage, and create a little diagram again.\nI think this is a lot better. The concepts from the specification are now all present in our design, and the structure also reflects the structure in the specs.\nNow there‚Äôs one more thing: I don‚Äôt think the Receiver part of MessageReceiver is entirely accurate. It does more than just receiving a message. I think it‚Äôs more accurate to say that it handles messages (if you have better ideas, let me know, naming is hard). So I think MessageHandler is a more accurate name. Let‚Äôs stick with that for now.\nFinishing the client Hello, friend1 We have a SocketClient that sends newline-terminated strings to the server. I think that‚Äôs actually enough to start working on a Robot. Let‚Äôs do that, and see what we‚Äôll end up with.\nclass RobotTest { @Test fun `initially not launched`() { val robot = Robot() assertThat(robot.launched).isFalse() } } Make it compile by creating the Robot class with a launch property.\nclass Robot { val launched: Boolean = false } Our test immediately passes. Now, let‚Äôs launch the robot!\n@Test fun `launch the robot`() { val port = startServerApplication() val client = SocketClient(port) val robot = Robot(client) robot.launch() assertThat(robot.launched).isTrue() } Make it compile and watch it fail.\nclass Robot(client: SocketClient) { val launched: Boolean = false fun launch() { } } I need to adjust our first Robot test as well, because the constructor has changed.\n@Test fun `initially not launched`() { val port = startServerApplication() val client = SocketClient(port) val robot = Robot(client) assertThat(robot.launched).isFalse() } Now let‚Äôs implement Robot::launch.\nclass Robot(private val socketClient: SocketClient) { var launched: Boolean = false fun launch() { socketClient.send(RequestMessage(\"launch\").toJSON()) launched = true } } Hmm, RequestMessage does not yet have a toJSON function. Let‚Äôs comment the launch implementation, @Ignore the test we just created, and add that first.\nclass RequestMessageTest { // ... @Test fun `serialize to JSON`() { val json = RequestMessage(\"launch\").toJSON() assertThat(json).isEqualTo(\"\"\"{\"command\":\"launch\"}\"\"\") } } We already know how to do this, so let‚Äôs make it compile and make it pass in one go.\ndata class RequestMessage(val command: String) { fun toJSON(): String { return Json.encodeToString(this) } // ... } Done. Let‚Äôs go back to Robot::launch again. Enable the test again, uncomment our code and watch it pass. That was easy! But wait, it looks like we did more than was needed to make the test pass, let‚Äôs check that. Yes, the test still passes if we remove the call to SocketClient.\nfun launch() { launched = true } What test could we add to validate that we actually use the SocketClient? We could test that launch fails if we don‚Äôt start the server application. It should fail because the Socket created in SocketClient::send will throw a java.net.ConnectException when it doesn‚Äôt succeed at creating a TCP connection. Let‚Äôs try that.\n@Test fun `launch when the server is not running`() { val client = SocketClient(32323) val robot = Robot(client) assertThat { robot.launch() }.isFailure() assertThat(robot.launched).isFalse() } This test fails, like expected, because launch doesn‚Äôt even try to connect to the server. Let‚Äôs fix launch by adding the call to SocketClient again.\nfun launch() { socketClient.send(RequestMessage(\"launch\").toJSON()) launched = true } Now all tests pass, and all functionality is covered by a test.\nAre we done? In the first post in this series, we looked at what a walking skeleton actually is. Let‚Äôs review:\nA ‚Äúwalking skeleton‚Äù is an implementation of the thinnest possible slice of real functionality that we can automatically build, deploy, and test end-to-end. It should include just enough of the automation, the major components, and communication mechanisms to allow us to start working on the first feature.\nReading this, I think we‚Äôre almost done with our walking skeleton, but not entirely, for two reasons. First, we can‚Äôt perform an end-to-end test yet, because we can‚Äôt start the client and the server as standalone processes. We need a main function for that. Second, I think we‚Äôre missing a ‚Äúmajor component‚Äù: The robot‚Äôs view of the world.\nThe world through the robot‚Äôs eyes We already have a World class in the server package. This class represents the world, as seen by the server. It contains (or rather: will contain) all information of the entire map (obstacles, pits, mines) and knows (ehm, will know) where all robots are and what they are doing. However, from the spec we know that the robot has a very limited view of the world. It gathers information by moving around and scanning its surroundings.\nDo I want this to be in the walking skeleton? Do we need it to start working on the first feature? I‚Äôm tempted to say yes, but in all honesty I don‚Äôt think we need it right now. Sure, Robot using SocketClient directly is something we will want to change at some point, but I don‚Äôt think it‚Äôs necessary for the tiny slice of functionality we chose for our walking skeleton. Let‚Äôs skip this for now, and wait until we have an actual need for it.\nEnd-to-end That leaves us with the need for an end-to-end test. To be able to do this, we need a main function. However, we need to be able to launch the client and the server as standalone processes. Let‚Äôs use command-line arguments for that. If the first argument is server, we‚Äôll start a server, if it is client, we‚Äôll require a second argument containing the port to connect to, and start a client.\nSince this is the outer-most edge of the application, I‚Äôm not going to use TDD.\nfun main(args: Array) { if (args.isEmpty()) notEnoughArguments() when (args[0]) { \"server\" -\u003e runServer() \"client\" -\u003e { if (args.size \u003c 2) notEnoughArguments() runClient(args[1].toInt()) } } } private fun notEnoughArguments() { System.err.println(\"Not enough arguments!\") exitProcess(1) } private fun runServer() { val port = startServerApplication() println(\"Server running on port $port\") } private fun runClient(port: Int) { println(\"Connecting to server on port $port...\") Robot(SocketClient(port)).launch() println(\"Robot launched!\") } Next, let‚Äôs add the application plugin to our Gradle configuration and configure a main class, so we can create a distribution for our game.\nplugins { kotlin(\"jvm\") version \"1.7.0\" kotlin(\"plugin.serialization\") version \"1.7.0\" application } // ... application { mainClass.set(\"nl.dirkgroot.robotworlds.RobotWorldsKt\") } Now, we can use ./gradlew assemble to create our distribution. This creates a game/build/distributions directory containing our distribution in TAR and ZIP format. We also get a game/buid/install directory containing an uncompressed distribution, which can be used immediately.\nBased on what we built so far, we expect the server to report the port it‚Äôs listening on and keep running until the client connects and launches its robot. After that the server should exit. Let‚Äôs give it a try, shall we?\nSuccess üéâ! On the left you can see that I started the server. On the right, you can see that I started the client using the port number reported by the server. The client successfully connected to the server, the launch command was handled successfully and the server stopped after that.\nWhen I start the client while the server isn‚Äôt running I expect to be greeted with a stack trace, because we don‚Äôt have proper error handling in place yet.\nbash-5.1$ ./game client 62226 Connecting to server on port 62226... Exception in thread \"main\" java.net.ConnectException: Connection refused ... at nl.dirkgroot.robotworlds.client.SocketClient.send(SocketClient.kt:7) at nl.dirkgroot.robotworlds.client.Robot.launch(Robot.kt:9) at nl.dirkgroot.robotworlds.RobotWorldsKt.runClient(RobotWorlds.kt:35) at nl.dirkgroot.robotworlds.RobotWorldsKt.main(RobotWorlds.kt:18) Walking skeleton: Done! That‚Äôs it! We created a tiny slice of end-to-end functionality to set us up for the development of our first feature. All code, except for the outer-most edge (the main method and its siblings) is covered with automated tests, and we performed a manual end-to-end test.\nFor all intents and purposes, I consider the game to be potentially shippable. The only reason we‚Äôre not shipping is because the game lacks features and polish (we don‚Äôt want to see a stack trace in the final product).\nI think this is a good time for a retrospective.\nRetrospective Ubiquitous language We started by observing that the terminology we used in the code didn‚Äôt fully match the terminology which is used in the spec. We fixed this by renaming two classes. I think it‚Äôs important to make sure that the terminology used in the code matches the terminology of the problem domain. This makes it easier to understand code, because we don‚Äôt need to translate between different sets of terminology. The Domain-Driven Design method makes this very explicit by striving for a ‚Äúubiquitous language‚Äù, a language shared by everyone involved in the project, from end users to software developers.\nYAGNI (again) I forgot to apply the YAGNI principle when implementing the Robot::launch method. Instead of writing just enough code to make the test pass, I added a line of code I knew I was going to need. It wasn‚Äôt a big deal, and it was fixed easily, but it‚Äôs still food for thought.\nI think this little example is a nice showcase of why the YAGNI principle is so powerful. By making sure every line of production code we add is ‚Äújustified‚Äù by a failing test, we don‚Äôt just achieve high line and branch coverage. We also achieve high behavioural coverage, as I like to call it, which to me is the primary goal to strive for with TDD, when it comes to coverage. High line and branch coverage are consequences, not goals in and of themselves.\nPrivacy While glossing over the code we created, I noticed that the setter for Robot::launched is public. Let‚Äôs make it private for good measure.\nclass Robot(private val client: SocketClient) { var launched: Boolean = false private set // ... } Tests still pass ‚û°Ô∏è commit.\nThanks for reading! As always, you can view the source code on GitHub: https://github.com/dirkgroot/robot-worlds\nI couldn‚Äôt resist a Mr. Robot reference ü§ñ.¬†‚Ü©Ô∏é\n","wordCount":"1838","inLanguage":"en","datePublished":"2022-06-25T16:20:22Z","dateModified":"2022-06-25T16:20:22Z","author":{"@type":"Person","name":"Dirk Groot"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.dirkgroot.nl/posts/robot-worlds/04-end-to-end/"},"publisher":{"@type":"Organization","name":"Dirk Groot","logo":{"@type":"ImageObject","url":"https://blog.dirkgroot.nl/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.dirkgroot.nl accesskey=h title="Dirk Groot (Alt + H)">Dirk Groot</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.dirkgroot.nl/ title=Blog><span>Blog</span></a></li><li><a href=https://blog.dirkgroot.nl/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.dirkgroot.nl/series/ title=Series><span>Series</span></a></li><li><a href=https://blog.dirkgroot.nl/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.dirkgroot.nl/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.dirkgroot.nl/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.dirkgroot.nl>Home</a>&nbsp;¬ª&nbsp;<a href=https://blog.dirkgroot.nl/posts/>Posts</a></div><h1 class=post-title>Robot Worlds 4: End to end</h1><div class=post-meta><span title='2022-06-25 16:20:22 +0000 UTC'>June 25, 2022</span>&nbsp;¬∑&nbsp;9 min&nbsp;¬∑&nbsp;Dirk Groot</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#recap aria-label=Recap>Recap</a><ul><li><a href=#design-so-far aria-label="Design so far">Design so far</a></li><li><a href=#terminology aria-label=Terminology>Terminology</a></li></ul></li><li><a href=#finishing-the-client aria-label="Finishing the client">Finishing the client</a><ul><li><a href=#hello-friend1 aria-label="Hello, friend1">Hello, friend<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></a></li><li><a href=#are-we-done aria-label="Are we done?">Are we done?</a></li><li><a href=#the-world-through-the-robots-eyes aria-label="The world through the robot&amp;rsquo;s eyes">The world through the robot&rsquo;s eyes</a></li><li><a href=#end-to-end aria-label=End-to-end>End-to-end</a></li></ul></li><li><a href=#walking-skeleton-done aria-label="Walking skeleton: Done!">Walking skeleton: Done!</a></li><li><a href=#retrospective aria-label=Retrospective>Retrospective</a><ul><li><a href=#ubiquitous-language aria-label="Ubiquitous language">Ubiquitous language</a></li><li><a href=#yagni-again aria-label="YAGNI (again)">YAGNI (again)</a></li><li><a href=#privacy aria-label=Privacy>Privacy</a></li></ul></li></ul></div></details></div><div class=post-content><summary class=dg-summary>I feel like we&rsquo;re almost done with our walking skeleton. Today, I&rsquo;ll try to finish it.</summary><h2 id=recap>Recap<a hidden class=anchor aria-hidden=true href=#recap>#</a></h2><h3 id=design-so-far>Design so far<a hidden class=anchor aria-hidden=true href=#design-so-far>#</a></h3><p>It&rsquo;s been a few days since I wrote the last article, so let&rsquo;s take a moment to review our design so far. Currently, the
game consists of two &ldquo;chunks&rdquo;, or components: the <code>client</code> and the <code>server</code>.</p><figure class="dg-figure-border dg-figure-padding"><img loading=lazy src=class-diagram.svg></figure><p>Step by step, we&rsquo;ve been working our way up the call stack, starting with <code>World</code>. In the <a href=../03-client>previous post</a>,
we created <code>SocketClient</code>, which means we&rsquo;re now able to send a JSON string to the server over TCP, and get a JSON
string back as a reply.</p><h3 id=terminology>Terminology<a hidden class=anchor aria-hidden=true href=#terminology>#</a></h3><p>Before we move on, let&rsquo;s look at the terminology we&rsquo;re using. I&rsquo;m seeing an inconsistency I&rsquo;d like to address. Making a
little diagram like this often helps to make these kinds of inconsistencies obvious. From this diagram, it&rsquo;s quite
obvious that we&rsquo;re using four words, without making it obvious how these words are related to each other: <em>message</em>,
<em>request</em>, <em>command</em> and <em>result</em>.</p><p>All of these words are actually used in the protocol specification. In my words, the spec says that the client sends a
<em>request</em> <em>message</em> containing a <em>command</em>, and the server replies with a response <em>message</em>, containing a <em>result</em>.
This structure is not visible in our design. Let&rsquo;s try to make this more obvious.</p><p>Let&rsquo;s rename <code>Request</code> to <code>RequestMesage</code>, and <code>CommandResult</code> to <code>ResponseMessage</code>, and create a little diagram again.</p><figure class="dg-figure-border dg-figure-padding"><img loading=lazy src=class-diagram-rename.svg></figure><p>I think this is a lot better. The concepts from the specification are now all present in our design, and the structure
also reflects the structure in the specs.</p><p>Now there&rsquo;s one more thing: I don&rsquo;t think the <code>Receiver</code> part of <code>MessageReceiver</code> is entirely accurate. It does more
than just receiving a message. I think it&rsquo;s more accurate to say that it <em>handles</em> messages (if you have better ideas,
let me know, naming is hard). So I think <code>MessageHandler</code> is a more accurate name. Let&rsquo;s stick with that for now.</p><h2 id=finishing-the-client>Finishing the client<a hidden class=anchor aria-hidden=true href=#finishing-the-client>#</a></h2><h3 id=hello-friend1>Hello, friend<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup><a hidden class=anchor aria-hidden=true href=#hello-friend1>#</a></h3><p>We have a <code>SocketClient</code> that sends newline-terminated strings to the server. I think that&rsquo;s actually enough to start
working on a <code>Robot</code>. Let&rsquo;s do that, and see what we&rsquo;ll end up with.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> RobotTest {
</span></span><span style=display:flex><span>    @Test
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> `initially not launched`() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> robot = Robot()
</span></span><span style=display:flex><span>        assertThat(robot.launched).isFalse()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Make it compile by creating the <code>Robot</code> class with a <code>launch</code> property.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Robot {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> launched: Boolean = <span style=color:#fff;font-weight:700>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our test immediately passes. Now, let&rsquo;s launch the robot!</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `launch the robot`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = startServerApplication()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> client = SocketClient(port)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> robot = Robot(client)
</span></span><span style=display:flex><span>    robot.launch()
</span></span><span style=display:flex><span>    assertThat(robot.launched).isTrue()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Make it compile and watch it fail.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Robot(client: SocketClient) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> launched: Boolean = <span style=color:#fff;font-weight:700>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> launch() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I need to adjust our first <code>Robot</code> test as well, because the constructor has changed.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `initially not launched`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = startServerApplication()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> client = SocketClient(port)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> robot = Robot(client)
</span></span><span style=display:flex><span>    assertThat(robot.launched).isFalse()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now let&rsquo;s implement <code>Robot::launch</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Robot(<span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>val</span> socketClient: SocketClient) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>var</span> launched: Boolean = <span style=color:#fff;font-weight:700>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> launch() {
</span></span><span style=display:flex><span>        socketClient.send(RequestMessage(<span style=color:#0ff;font-weight:700>&#34;launch&#34;</span>).toJSON())
</span></span><span style=display:flex><span>        launched = <span style=color:#fff;font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Hmm, <code>RequestMessage</code> does not yet have a <code>toJSON</code> function. Let&rsquo;s comment the <code>launch</code> implementation, <code>@Ignore</code> the
test we just created, and add that first.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> RequestMessageTest {
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// ...
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    @Test
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> `serialize to JSON`() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> json = RequestMessage(<span style=color:#0ff;font-weight:700>&#34;launch&#34;</span>).toJSON()
</span></span><span style=display:flex><span>        assertThat(json).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;command&#34;:&#34;launch&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We already know how to do this, so let&rsquo;s make it compile and make it pass in one go.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>data</span> <span style=color:#fff;font-weight:700>class</span> RequestMessage(<span style=color:#fff;font-weight:700>val</span> command: String) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> toJSON(): String {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> Json.encodeToString(<span style=color:#fff;font-weight:700>this</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// ...
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>}
</span></span></code></pre></div><p>Done. Let&rsquo;s go back to <code>Robot::launch</code> again. Enable the test again, uncomment our code and watch it pass. That was
easy! But wait, it looks like we did more than was needed to make the test pass, let&rsquo;s check that. Yes, the test still
passes if we remove the call to <code>SocketClient</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> launch() {
</span></span><span style=display:flex><span>    launched = <span style=color:#fff;font-weight:700>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What test could we add to validate that we actually use the <code>SocketClient</code>? We could test that <code>launch</code> fails if we
don&rsquo;t start the server application. It should fail because the <code>Socket</code> created in <code>SocketClient::send</code> will throw a
<code>java.net.ConnectException</code> when it doesn&rsquo;t succeed at creating a TCP connection. Let&rsquo;s try that.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `launch when the server is not running`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> client = SocketClient(<span style=color:#ff0;font-weight:700>32323</span>)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> robot = Robot(client)
</span></span><span style=display:flex><span>    assertThat { robot.launch() }.isFailure()
</span></span><span style=display:flex><span>    assertThat(robot.launched).isFalse()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This test fails, like expected, because <code>launch</code> doesn&rsquo;t even try to connect to the server. Let&rsquo;s fix <code>launch</code> by adding
the call to <code>SocketClient</code> again.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> launch() {
</span></span><span style=display:flex><span>    socketClient.send(RequestMessage(<span style=color:#0ff;font-weight:700>&#34;launch&#34;</span>).toJSON())
</span></span><span style=display:flex><span>    launched = <span style=color:#fff;font-weight:700>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now all tests pass, and all functionality is covered by a test.</p><h3 id=are-we-done>Are we done?<a hidden class=anchor aria-hidden=true href=#are-we-done>#</a></h3><p>In the first post in this series, we looked
at <a href=../01-walking-skeleton#walking-skeleton>what a walking skeleton actually is</a>. Let&rsquo;s review:</p><blockquote><p>A ‚Äúwalking skeleton‚Äù is an implementation of the thinnest possible slice of real functionality that we can
automatically build, deploy, and test end-to-end. It should include just enough of the automation, the major
components, and communication mechanisms to allow us to start working on the first feature.</p></blockquote><p>Reading this, I think we&rsquo;re almost done with our walking skeleton, but not entirely, for two reasons. First, we can&rsquo;t
perform an end-to-end test yet, because we can&rsquo;t start the client and the server as standalone processes. We need
a <code>main</code> function for that. Second, I think we&rsquo;re missing a &ldquo;major component&rdquo;: The robot&rsquo;s view of the world.</p><h3 id=the-world-through-the-robots-eyes>The world through the robot&rsquo;s eyes<a hidden class=anchor aria-hidden=true href=#the-world-through-the-robots-eyes>#</a></h3><p>We already have a <code>World</code> class in the <code>server</code> package. This class represents the world, as seen by the server. It
contains (or rather: will contain) all information of the entire map (obstacles, pits, mines) and knows (ehm, will know)
where all robots are and what they are doing. However, from the spec we know that the robot has a very limited view of
the world. It gathers information by moving around and scanning its surroundings.</p><p>Do I want this to be in the walking skeleton? Do we need it to start working on the first feature? I&rsquo;m tempted to say
yes, but in all honesty I don&rsquo;t think we need it right now. Sure, <code>Robot</code> using <code>SocketClient</code> directly is something we
will want to change at some point, but I don&rsquo;t think it&rsquo;s necessary for the tiny slice of functionality we chose for our
walking skeleton. Let&rsquo;s skip this for now, and wait until we have an actual need for it.</p><h3 id=end-to-end>End-to-end<a hidden class=anchor aria-hidden=true href=#end-to-end>#</a></h3><p>That leaves us with the need for an end-to-end test. To be able to do this, we need a <code>main</code> function. However, we need
to be able to launch the client and the server as standalone processes. Let&rsquo;s use command-line arguments for that. If
the first argument is <code>server</code>, we&rsquo;ll start a server, if it is <code>client</code>, we&rsquo;ll require a second argument containing the
port to connect to, and start a client.</p><p>Since this is the outer-most edge of the application, I&rsquo;m not going to use TDD.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> main(args: Array&lt;String&gt;) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (args.isEmpty())
</span></span><span style=display:flex><span>        notEnoughArguments()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>when</span> (args[<span style=color:#ff0;font-weight:700>0</span>]) {
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#34;server&#34;</span> -&gt; runServer()
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#34;client&#34;</span> -&gt; {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>if</span> (args.size &lt; <span style=color:#ff0;font-weight:700>2</span>)
</span></span><span style=display:flex><span>                notEnoughArguments()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            runClient(args[<span style=color:#ff0;font-weight:700>1</span>].toInt())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> notEnoughArguments() {
</span></span><span style=display:flex><span>    System.err.println(<span style=color:#0ff;font-weight:700>&#34;Not enough arguments!&#34;</span>)
</span></span><span style=display:flex><span>    exitProcess(<span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> runServer() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = startServerApplication()
</span></span><span style=display:flex><span>    println(<span style=color:#0ff;font-weight:700>&#34;Server running on port </span><span style=color:#0ff;font-weight:700>$port</span><span style=color:#0ff;font-weight:700>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> runClient(port: Int) {
</span></span><span style=display:flex><span>    println(<span style=color:#0ff;font-weight:700>&#34;Connecting to server on port </span><span style=color:#0ff;font-weight:700>$port</span><span style=color:#0ff;font-weight:700>...&#34;</span>)
</span></span><span style=display:flex><span>    Robot(SocketClient(port)).launch()
</span></span><span style=display:flex><span>    println(<span style=color:#0ff;font-weight:700>&#34;Robot launched!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, let&rsquo;s add the <code>application</code> plugin to our Gradle configuration and configure a main class, so we can create a
distribution for our game.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>plugins {
</span></span><span style=display:flex><span>    kotlin(<span style=color:#0ff;font-weight:700>&#34;jvm&#34;</span>) version <span style=color:#0ff;font-weight:700>&#34;1.7.0&#34;</span>
</span></span><span style=display:flex><span>    kotlin(<span style=color:#0ff;font-weight:700>&#34;plugin.serialization&#34;</span>) version <span style=color:#0ff;font-weight:700>&#34;1.7.0&#34;</span>
</span></span><span style=display:flex><span>    application
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// ...
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>application {
</span></span><span style=display:flex><span>    mainClass.<span style=color:#fff;font-weight:700>set</span>(<span style=color:#0ff;font-weight:700>&#34;nl.dirkgroot.robotworlds.RobotWorldsKt&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, we can use <code>./gradlew assemble</code> to create our distribution. This creates a <code>game/build/distributions</code> directory
containing our distribution in TAR and ZIP format. We also get a <code>game/buid/install</code> directory containing an
uncompressed distribution, which can be used immediately.</p><p>Based on what we built so far, we expect the server to report the port it&rsquo;s listening on and keep running until the
client connects and launches its robot. After that the server should exit. Let&rsquo;s give it a try, shall we?</p><figure class="dg-figure-border dg-figure-padding"><img loading=lazy src=end-to-end.gif></figure><p>Success üéâ! On the left you can see that I started the server. On the right, you can see that I started the client using
the port number reported by the server. The client successfully connected to the server, the launch command was handled
successfully and the server stopped after that.</p><p>When I start the client while the server isn&rsquo;t running I expect to be greeted with a stack trace, because we don&rsquo;t have
proper error handling in place yet.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>bash-5.1$ ./game client 62226
</span></span><span style=display:flex><span>Connecting to server on port 62226...
</span></span><span style=display:flex><span>Exception in thread &#34;main&#34; java.net.ConnectException: Connection refused
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>	at nl.dirkgroot.robotworlds.client.SocketClient.send(SocketClient.kt:7)
</span></span><span style=display:flex><span>	at nl.dirkgroot.robotworlds.client.Robot.launch(Robot.kt:9)
</span></span><span style=display:flex><span>	at nl.dirkgroot.robotworlds.RobotWorldsKt.runClient(RobotWorlds.kt:35)
</span></span><span style=display:flex><span>	at nl.dirkgroot.robotworlds.RobotWorldsKt.main(RobotWorlds.kt:18)
</span></span></code></pre></div><h2 id=walking-skeleton-done>Walking skeleton: Done!<a hidden class=anchor aria-hidden=true href=#walking-skeleton-done>#</a></h2><p>That&rsquo;s it! We created a tiny slice of end-to-end functionality to set us up for the development of our first feature.
All code, except for the outer-most edge (the <code>main</code> method and its siblings) is covered with automated tests, and we
performed a manual end-to-end test.</p><p>For all intents and purposes, I consider the game to be potentially shippable. The only reason we&rsquo;re not shipping is
because the game lacks features and polish (we don&rsquo;t want to see a stack trace in the final product).</p><p>I think this is a good time for a retrospective.</p><h2 id=retrospective>Retrospective<a hidden class=anchor aria-hidden=true href=#retrospective>#</a></h2><h3 id=ubiquitous-language>Ubiquitous language<a hidden class=anchor aria-hidden=true href=#ubiquitous-language>#</a></h3><p>We started by observing that the terminology we used in the code didn&rsquo;t fully match the terminology which is used in the
spec. We fixed this by renaming two classes. I think it&rsquo;s important to make sure that the terminology used in the code
matches the terminology of the problem domain. This makes it easier to understand code, because we don&rsquo;t need to
translate between different sets of terminology.
The <a href=https://en.wikipedia.org/wiki/Domain-driven_design>Domain-Driven Design</a> method makes this very explicit by
striving for a &ldquo;ubiquitous language&rdquo;, a language shared by everyone involved in the project, from end users to software
developers.</p><h3 id=yagni-again>YAGNI (again)<a hidden class=anchor aria-hidden=true href=#yagni-again>#</a></h3><p>I forgot to apply the YAGNI principle when implementing the <code>Robot::launch</code> method. Instead of writing just enough code
to make the test pass, I added a line of code I knew I was going to need. It wasn&rsquo;t a big deal, and it was fixed easily,
but it&rsquo;s still food for thought.</p><p>I think this little example is a nice showcase of why the YAGNI principle is so powerful. By making sure every line of
production code we add is &ldquo;justified&rdquo; by a failing test, we don&rsquo;t just achieve high line and branch coverage. We also
achieve high <em>behavioural coverage</em>, as I like to call it, which to me is the primary goal to strive for with TDD, when
it comes to coverage. High line and branch coverage are consequences, not goals in and of themselves.</p><h3 id=privacy>Privacy<a hidden class=anchor aria-hidden=true href=#privacy>#</a></h3><p>While glossing over the code we created, I noticed that the setter for <code>Robot::launched</code> is public. Let&rsquo;s make it
private for good measure.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Robot(<span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>val</span> client: SocketClient) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>var</span> launched: Boolean = <span style=color:#fff;font-weight:700>false</span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>set</span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// ...
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>}
</span></span></code></pre></div><p>Tests still pass ‚û°Ô∏è commit.</p><p>Thanks for reading! As always, you can view the source code on GitHub: <a href=https://github.com/dirkgroot/robot-worlds>https://github.com/dirkgroot/robot-worlds</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>I couldn&rsquo;t resist a Mr. Robot reference ü§ñ.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.dirkgroot.nl/tags/walking-skeleton/>walking-skeleton</a></li><li><a href=https://blog.dirkgroot.nl/tags/robot-worlds/>robot-worlds</a></li><li><a href=https://blog.dirkgroot.nl/tags/kotlin/>kotlin</a></li><li><a href=https://blog.dirkgroot.nl/tags/tdd/>tdd</a></li><li><a href=https://blog.dirkgroot.nl/tags/yagni/>yagni</a></li></ul><nav class=paginav><a class=next href=https://blog.dirkgroot.nl/posts/robot-worlds/03-client/><span class=title>Next ¬ª</span><br><span>Robot Worlds 3: Client</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.dirkgroot.nl>Dirk Groot</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=dg-extended-footer><div class=social-icons><a href=https://github.com/dirkgroot target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.linkedin.com/in/dirkgroot77 target=_blank rel="noopener noreferrer me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a><a href=https://twitter.com/dirk__groot target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>