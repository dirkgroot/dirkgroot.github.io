<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Robot Worlds 3: Client | Dirk Groot</title><meta name=keywords content="walking-skeleton,robot-worlds,kotlin,tdd,refactoring"><meta name=description content="
    Now that we have a server that can receive a request over TCP, handle it and send a response back, it looks like a good
time to start working on the client. We&rsquo;ll also think about how we want to test our walking skeleton end-to-end.
"><meta name=author content="Dirk Groot"><link rel=canonical href=https://blog.dirkgroot.nl/posts/robot-worlds/03-client/><link crossorigin=anonymous href=/assets/css/stylesheet.7a9a232bd263c7c728764d673e311e223485d79aec414071c61373b461fdb01f.css integrity="sha256-epojK9Jjx8codk1nPjEeIjSF15rsQUBxxhNztGH9sB8=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.dirkgroot.nl/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.dirkgroot.nl/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.dirkgroot.nl/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.dirkgroot.nl/apple-touch-icon.png><link rel=mask-icon href=https://blog.dirkgroot.nl/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=/css/theme-overrides.css><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-TBE6V39YXJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TBE6V39YXJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Robot Worlds 3: Client"><meta property="og:description" content="
    Now that we have a server that can receive a request over TCP, handle it and send a response back, it looks like a good
time to start working on the client. We&rsquo;ll also think about how we want to test our walking skeleton end-to-end.
"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.dirkgroot.nl/posts/robot-worlds/03-client/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-21T20:40:34+00:00"><meta property="article:modified_time" content="2022-06-21T20:40:34+00:00"><meta property="og:see_also" content="https://blog.dirkgroot.nl/posts/robot-worlds/02-communication/"><meta property="og:see_also" content="https://blog.dirkgroot.nl/posts/robot-worlds/01-walking-skeleton/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Robot Worlds 3: Client"><meta name=twitter:description content="
    Now that we have a server that can receive a request over TCP, handle it and send a response back, it looks like a good
time to start working on the client. We&rsquo;ll also think about how we want to test our walking skeleton end-to-end.
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.dirkgroot.nl/posts/"},{"@type":"ListItem","position":3,"name":"Robot Worlds 3: Client","item":"https://blog.dirkgroot.nl/posts/robot-worlds/03-client/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Robot Worlds 3: Client","name":"Robot Worlds 3: Client","description":" Now that we have a server that can receive a request over TCP, handle it and send a response back, it looks like a good time to start working on the client. We\u0026rsquo;ll also think about how we want to test our walking skeleton end-to-end. ","keywords":["walking-skeleton","robot-worlds","kotlin","tdd","refactoring"],"articleBody":" Now that we have a server that can receive a request over TCP, handle it and send a response back, it looks like a good time to start working on the client. We’ll also think about how we want to test our walking skeleton end-to-end. Progress Let’s grab the crude sequence diagram we drew in part 1 of this series and mark the parts we already covered in the two previous posts with a green color.\nAs you can see, our walking skeleton is almost an end-to-end skeleton. The only things left to do are to create a minimal client application, and write a main method for our server, so it can be started as a standalone program.\nDecisions Before we start coding, I’d like to make some decisions.\nHow will the player interact with the client? The specification doesn’t require any particular way of presenting the game to the player. As I’m the only stakeholder for this little project, and I happen to like ASCII-art based roguelike games, and I don’t feel like programming with Swing, or JavaFX or some other UI/graphics library, we’ll create a text-based user interface for the client. The player will control the his/her robot with the keyboard.\nThere, that was easy. Let’s think about testing.\nTesting end-to-end Up until now, we’ve created small tests, focused on small parts of the code. However, because we didn’t use test doubles1, every step up the call stack resulted in tests which covered more code. Now our goal with our walking skeleton is to get to a point where we can perform an end-to-end test of the tiny slice of functionality we created. That way we extend our test coverage to the deployment of our system and the integration of the various standalone components of the system2.\nWith an end-to-end test, rather than calling specific parts of the application code directly from our test code, we want to execute the test against the actual program. In our case, an end-to-end test scenario could look something like this:\nInstall and configure the server, and start it up. Install and configure the client, and start it up. Perform a small, well chosen, number of scenarios to make sure that all components of the system are working together nicely. If this were a “real” project, I would set up automated end-to-end tests as part of the walking skeleton, using test frameworks like Cypress or Robot Framework (in the case of web applications). For this little hobby project, I don’t mind having to execute end-to-end tests manually.\nI will, however, keep on using the Humble Object pattern to separate code that performs keyboard and screen I/O from code that can be automatically tested with JUnit tests.\nLet’s get to it Humble socket client The server has a humble SocketListener, which accepts incoming connections, passes requests to MessageReceiver and sends the response back to the client. Let’s mirror this in our client by creating a humble SocketClient.\nSo, I guess the test for our SocketClient should look something like our test for MessageReceiver. We need to set up a SocketListener for this, so our client module needs a test dependency on the server module. Let’s do that first.\ndependencies { testImplementation(kotlin(\"test\")) testImplementation(\"org.jetbrains.kotlin:kotlin-reflect:1.7.0\") testImplementation(\"com.willowtreeapps.assertk:assertk:0.25\") testImplementation(project(\":server\")) } Now, let’s write a test.\n@Test fun `invoke launch command with JSON message`() { val socketListener = SocketListener(MessageReceiver(World())) val socketClient = SocketClient(socketListener.port) val result = socketClient.send(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(result).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } Make it compile by creating the SocketClient class with a stubbed send method.\nclass SocketClient(port: Int) { fun send(message: String): String { return \"\" } } Now the test compiles, and it fails: expected:\u003c\"[{\"result\":\"OK\"}]\"\u003e but was:\u003c\"[]\"\u003e. Let’s make it pass. We’ll need to upgrade the constructor parameter port to a private property.\nclass SocketClient(private val port: Int) { fun send(message: String): String { return Socket(\"127.0.0.1\", port).use { sendMessage(it, message) receiveResponse(it) } } private fun sendMessage(socket: Socket, message: String) { socket.getOutputStream().writer().apply { write(\"$message\\n\") flush() } } private fun receiveResponse(socket: Socket) = socket.getInputStream().bufferedReader().readLine() } That’s quite a chunk of code to write to make one single test pass. Truth is, I’ve committed a horrible sin by copy/pasted and adjusted some code from the SocketListenerTest class we wrote in the previous post. This means we’ve now got some duplication to eliminate. Also, I don’t like the way we start a SocketListener in our test. Let’s address the last issue first.\nDecoupling To start the SocketListener from our test, we need to set up all the internals of the server.\nval socketListener = SocketListener(MessageReceiver(World())) We’ve introduced coupling3 between the client module’s test code and the internal structure of the server. This means that if we change the internal structure of the server, we must change this code as well. That’s not good. We prefer our tests to be sensitive to the behaviour of the system, not to the structure of the system4.\nLet’s refactor step by step. First, we’ll make a bit more explicit that the test needs to start the server, and needs to know what port the server is running on. We’ll introduce a port variable.\nval socketListener = SocketListener(MessageReceiver(World())) val port = socketListener.port val socketClient = SocketClient(port) val result = socketClient.send(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(result).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") Then inline the socketListener variable.\nval port = SocketListener(MessageReceiver(World())).port val socketClient = SocketClient(port) val result = socketClient.send(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(result).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") Now we can remove the knowledge about the server module’s internals from the test method by extracting a method.\n@Test fun `invoke launch command with JSON message`() { val port = startServerApplication() val socketClient = SocketClient(port) val result = socketClient.send(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(result).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } private fun startServerApplication() = SocketListener(MessageReceiver(World())).port Finally, let’s move the newly created startServerApplication function to the server module. I’ve put it in a new source file called ServerApplication.kt in the root package of the server module.\npackage nl.dirkgroot.robotworlds fun startServerApplication() = SocketListener(MessageReceiver(World())).port There, we’ve encapsulated all knowledge about the internal structure of the server module into the startServerApplication function. By moving said function to the server module, we completely decoupled the test code in the client module from the internal structure of the server module.\nDuplication Let’s look at the duplication we introduced. Look back at the SocketClient class earlier in this post, and compare it to what we have in SocketListenerTest.\n@Test fun `handles a command`() { val socketListener = SocketListener(MessageReceiver(World())) val port = socketListener.port assertTimeoutPreemptively(Duration.ofSeconds(1)) { Socket(\"127.0.0.1\", port).use { socket -\u003e sendLaunchCommand(socket) val response = receiveResponse(socket) assertThat(response).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } } } private fun sendLaunchCommand(socket: Socket) { socket.getOutputStream().writer().apply { write(\"\"\"{ \"command\": \"launch\" }\"\"\" + \"\\n\") flush() } } private fun receiveResponse(socket: Socket) = socket.getInputStream().bufferedReader().readLine() Now this is not a 100% duplicate, but I think it’s fairly obvious that both classes create a socket connection, send a message and receive a response. If only we could use SocketClient in SocketListenerTest…\nSimplification I’m tempted to introduce a new module, named tcp-communication, move SocketClient to that module, and use this new module from the client and server module. But wait, why did we create separate modules for the server and the client? I don’t remember it being a very conscious decision. I guess I did it because I drew 2 separate containers in the container diagram. But now I think about it, having two separate containers just means that there are two separate processes. This doesn’t necessarily mean that they also need to be separate executables. We could just as well create one executable which can be started either in client or in server mode using a command-line switch.\nLet’s simplify the module structure, so we have just one module: game. I’ll do it step by step, like this:\nMove all code from client/src/main/kotlin to server/src/main/kotlin Move all code from client/src/test/kotlin to server/src/test/kotlin Remove the client module Rename the server to game Now there’s one thing I notice. In the client module I created a package called nl.dirkgroot.robotworlds.client, but in the server module I put everything in the nl.dirkgroot.robotworlds package. Let’s move the server code to nl.dirkgroot.robotworlds.server. All tests still pass, so everything went well.\nDeduplication Now that we have everything in one module, let’s see what we can do about the duplication we created. We’ll change the handles a command test in SocketListenerTest so it uses SocketClient.\n@Test fun `handles a command`() { val socketListener = SocketListener(MessageReceiver(World())) val port = socketListener.port assertTimeoutPreemptively(Duration.ofSeconds(1)) { val response = SocketClient(port).send(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(response).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } } The test passes, so we can delete the sendLaunchCommand and receiveResponse methods from SocketListenerTest, as those are not used anymore. Hmm, now there’s still duplication left. This test is basically the same as the test we wrote for SocketClient.\n@Test fun `invoke launch command with JSON message`() { val port = startServerApplication() val socketClient = SocketClient(port) val result = socketClient.send(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(result).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } The only differences are in how the socket listener is started and whether or not the test is timing out if no response is received for more than 1 second. One of these tests can be deleted, for sure. There’s no point in having two tests test exactly the same thing.\nI like the one with the timeout better, because it’s a little more robust than the one without, so let’s keep that one. This means that we can delete the SocketClientTest class entirely, because it only contains the test we’re going to delete.\nThis leaves us with a bit of an awkward situation, because now SocketListenerTest is responsible for testing both SocketClient and SocketListener. I don’t think this is necessarily a bad thing. After all, to me, the “unit” in unit testing is primarily a unit of behaviour - communication between client and server in this case - not a unit of structure (a particular class or function). The awkwardness is in the names of the test class and the tests.\nSo let’s just change the name of the test class to ClientServerCommunicationTest, and move it from the nl.dirkgroot.robotworlds.server package to nl.dirkgroot.robotworlds. Also, let’s change the initialisation part of the two tests to use the startServerApplication function, and rename handles a command to client can send a command to server over a TCP socket.\n@Test fun `listens on free TCP port when no port is given`() { val port = startServerApplication() Socket(\"127.0.0.1\", port).use { assertThat(it.isConnected).isTrue() } } @Test fun `client can send a command to server over a TCP socket`() { val port = startServerApplication() assertTimeoutPreemptively(Duration.ofSeconds(1)) { val response = SocketClient(port).send(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(response).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } } I think I like where this is going. Let’s do a retrospective.\nRetrospective Horrible sin I committed a horrible sin by copy/pasting code, but in my defense, we were in the red stage of the red/green/refactor cycle. When we’re in the red stage, our goal is to get to green as fast as possible, by any means necessary. And that’s what we did. In the refactor stage, we cleaned up our mess.\nWorking like this creates a very clear distinction between getting code to work and designing our code. Furthermore, as you can see from this little project so far, most of the design work is done after we get some code to work. We did very little design up front, and we did it just to get an idea of where we’re heading.\nWhy does TDD work like this? Why do we refactor afterwards, instead of designing it “the right way” up front? In my experience, no matter how much design you do up front, refactoring afterwards will always be necessary to keep the code clean and well-factored. We just cannot foresee and account for every design issue we will face. When we’re writing the code, and when we’re mindful of what we’re creating, that’s when the most valuable design insights occur, because the code is right in front of us, and not in some fantasy in our minds.\nIntegration By eliminating the duplication we introduced, we ended up with a test class which tests the communication between the client and the server. We started out by testing the SocketListener by creating some stub client code, because that’s all we could do at that point. When we created the SocketClient class, we didn’t need the stub code anymore and replaced it with the actual client code. The result is what I would call an integration test.\nI’ve seen code bases where “integration tests” consisted of client code being tested by stubbing or mocking the server in some way, and of server code being tested by stubbing the client. To me, this is not integration testing. If we want to test whether two components integrate well, the best possible way to do that is by letting them actually “talk” to each other. As we’ve seen, this doesn’t just result in testing the actual integration between components. It also results in the elimination of duplication and all the risks that come with it.\nLet’s see if we can finish our walking skeleton next time, so we can start building some real end-to-end features. Thanks for reading, see you next time!\nPS: Here’s the source code so far: https://github.com/dirkgroot/robot-worlds\nOr mocks, as most people call them. In reality, a mock is only one of many kinds of test doubles. Take a look at the Test Double patterns on http://xunitpatterns.com if you want to know more about the terminology around test doubles. ↩︎\nThere’s a lot more to say about end-to-end testing and testing strategy in general, but that’s beyond the scope of this series. ↩︎\nWatch Kent Beck explain what coupling is. ↩︎\nAgain, watch Kent Beck: Test Desiderata 2/12 Tests Should be Structure-Insensitive. ↩︎\n","wordCount":"2255","inLanguage":"en","datePublished":"2022-06-21T20:40:34Z","dateModified":"2022-06-21T20:40:34Z","author":{"@type":"Person","name":"Dirk Groot"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.dirkgroot.nl/posts/robot-worlds/03-client/"},"publisher":{"@type":"Organization","name":"Dirk Groot","logo":{"@type":"ImageObject","url":"https://blog.dirkgroot.nl/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.dirkgroot.nl accesskey=h title="Dirk Groot (Alt + H)">Dirk Groot</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.dirkgroot.nl/ title=Blog><span>Blog</span></a></li><li><a href=https://blog.dirkgroot.nl/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.dirkgroot.nl/series/ title=Series><span>Series</span></a></li><li><a href=https://blog.dirkgroot.nl/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.dirkgroot.nl/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.dirkgroot.nl/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.dirkgroot.nl>Home</a>&nbsp;»&nbsp;<a href=https://blog.dirkgroot.nl/posts/>Posts</a></div><h1 class=post-title>Robot Worlds 3: Client</h1><div class=post-meta><span title='2022-06-21 20:40:34 +0000 UTC'>June 21, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Dirk Groot</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#progress aria-label=Progress>Progress</a></li><li><a href=#decisions aria-label=Decisions>Decisions</a><ul><li><a href=#how-will-the-player-interact-with-the-client aria-label="How will the player interact with the client?">How will the player interact with the client?</a></li><li><a href=#testing-end-to-end aria-label="Testing end-to-end">Testing end-to-end</a></li></ul></li><li><a href=#lets-get-to-it aria-label="Let&amp;rsquo;s get to it">Let&rsquo;s get to it</a><ul><li><a href=#humble-socket-client aria-label="Humble socket client">Humble socket client</a></li><li><a href=#decoupling aria-label=Decoupling>Decoupling</a></li><li><a href=#duplication aria-label=Duplication>Duplication</a></li><li><a href=#simplification aria-label=Simplification>Simplification</a></li><li><a href=#deduplication aria-label=Deduplication>Deduplication</a></li></ul></li><li><a href=#retrospective aria-label=Retrospective>Retrospective</a><ul><li><a href=#horrible-sin aria-label="Horrible sin">Horrible sin</a></li><li><a href=#integration aria-label=Integration>Integration</a></li></ul></li></ul></div></details></div><div class=post-content><summary class=dg-summary>Now that we have a server that can receive a request over TCP, handle it and send a response back, it looks like a good
time to start working on the client. We&rsquo;ll also think about how we want to test our walking skeleton end-to-end.</summary><h2 id=progress>Progress<a hidden class=anchor aria-hidden=true href=#progress>#</a></h2><p>Let&rsquo;s grab the crude sequence diagram we drew in <a href=../01-walking-skeleton>part 1</a> of this series and mark the parts we
already covered in the two previous posts with a green color.</p><figure class="dg-figure-border dg-figure-padding"><img loading=lazy src=launch-sequence.svg></figure><p>As you can see, our walking skeleton is almost an end-to-end skeleton. The only things left to do are to create a
minimal client application, and write a <code>main</code> method for our server, so it can be started as a standalone program.</p><h2 id=decisions>Decisions<a hidden class=anchor aria-hidden=true href=#decisions>#</a></h2><p>Before we start coding, I&rsquo;d like to make some decisions.</p><h3 id=how-will-the-player-interact-with-the-client>How will the player interact with the client?<a hidden class=anchor aria-hidden=true href=#how-will-the-player-interact-with-the-client>#</a></h3><p>The specification doesn&rsquo;t require any particular way of presenting the game to the player. As I&rsquo;m the only stakeholder
for this little project, and I happen to like ASCII-art based roguelike games, and I don&rsquo;t feel like programming with
Swing, or JavaFX or some other UI/graphics library, we&rsquo;ll create a text-based user interface for the client. The player
will control the his/her robot with the keyboard.</p><p>There, that was easy. Let&rsquo;s think about testing.</p><h3 id=testing-end-to-end>Testing end-to-end<a hidden class=anchor aria-hidden=true href=#testing-end-to-end>#</a></h3><p>Up until now, we&rsquo;ve created small tests, focused on small parts of the code. However, because we didn&rsquo;t use <em>test
doubles</em><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, every step up the call stack resulted in tests which covered more code. Now our goal with our walking
skeleton is to get to a point where we can perform an end-to-end test of the tiny slice of functionality we created.
That way we extend our test coverage to the deployment of our system and the integration of the various standalone
components of the system<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>With an end-to-end test, rather than calling specific parts of the application code directly from our test code, we want
to execute the test against the actual program. In our case, an end-to-end test scenario could look something like
this:</p><ol><li>Install and configure the server, and start it up.</li><li>Install and configure the client, and start it up.</li><li>Perform a small, well chosen, number of scenarios to make sure that all components of the system are working
together nicely.</li></ol><p>If this were a &ldquo;real&rdquo; project, I would set up automated end-to-end tests as part of the walking skeleton, using test
frameworks like Cypress or Robot Framework (in the case of web applications). For this little hobby project, I don&rsquo;t
mind having to execute end-to-end tests manually.</p><p>I will, however, keep on using the <a href=../02-communication#humble-object>Humble Object</a> pattern to separate code that
performs keyboard and screen I/O from code that can be automatically tested with JUnit tests.</p><h2 id=lets-get-to-it>Let&rsquo;s get to it<a hidden class=anchor aria-hidden=true href=#lets-get-to-it>#</a></h2><h3 id=humble-socket-client>Humble socket client<a hidden class=anchor aria-hidden=true href=#humble-socket-client>#</a></h3><p>The server has a humble <code>SocketListener</code>, which accepts incoming connections, passes requests to <code>MessageReceiver</code> and
sends the response back to the client. Let&rsquo;s mirror this in our client by creating a humble <code>SocketClient</code>.</p><p>So, I guess the test for our <code>SocketClient</code> should look something like our test for <code>MessageReceiver</code>. We need to set up
a <code>SocketListener</code> for this, so our <code>client</code> module needs a test dependency on the <code>server</code> module. Let&rsquo;s do that first.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>dependencies {
</span></span><span style=display:flex><span>    testImplementation(kotlin(<span style=color:#0ff;font-weight:700>&#34;test&#34;</span>))
</span></span><span style=display:flex><span>    testImplementation(<span style=color:#0ff;font-weight:700>&#34;org.jetbrains.kotlin:kotlin-reflect:1.7.0&#34;</span>)
</span></span><span style=display:flex><span>    testImplementation(<span style=color:#0ff;font-weight:700>&#34;com.willowtreeapps.assertk:assertk:0.25&#34;</span>)
</span></span><span style=display:flex><span>    testImplementation(project(<span style=color:#0ff;font-weight:700>&#34;:server&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, let&rsquo;s write a test.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `invoke launch command with JSON message`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener(MessageReceiver(World()))
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> socketClient = SocketClient(socketListener.port)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> result = socketClient.send(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    assertThat(result).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Make it compile by creating the <code>SocketClient</code> class with a stubbed <code>send</code> method.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> SocketClient(port: Int) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> send(message: String): String {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> <span style=color:#0ff;font-weight:700>&#34;&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now the test compiles, and it fails: <code>expected:&lt;"[{"result":"OK"}]"> but was:&lt;"[]"></code>. Let&rsquo;s make it pass. We&rsquo;ll need to
upgrade the constructor parameter <code>port</code> to a private property.</p><a id=socket-client-class></a><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> SocketClient(<span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>val</span> port: Int) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> send(message: String): String {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> Socket(<span style=color:#0ff;font-weight:700>&#34;127.0.0.1&#34;</span>, port).use {
</span></span><span style=display:flex><span>            sendMessage(<span style=color:#fff;font-weight:700>it</span>, message)
</span></span><span style=display:flex><span>            receiveResponse(<span style=color:#fff;font-weight:700>it</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> sendMessage(socket: Socket, message: String) {
</span></span><span style=display:flex><span>        socket.getOutputStream().writer().apply {
</span></span><span style=display:flex><span>            write(<span style=color:#0ff;font-weight:700>&#34;</span><span style=color:#0ff;font-weight:700>$message</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>)
</span></span><span style=display:flex><span>            flush()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> receiveResponse(socket: Socket) =
</span></span><span style=display:flex><span>        socket.getInputStream().bufferedReader().readLine()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s quite a chunk of code to write to make one single test pass. Truth is, I&rsquo;ve committed a horrible sin by
copy/pasted and adjusted some code from the <code>SocketListenerTest</code> class we wrote in
the <a href=../02-communication#are-you-being-served>previous post</a>. This means we&rsquo;ve now got some duplication to eliminate.
Also, I don&rsquo;t like the way we start a <code>SocketListener</code> in our test. Let&rsquo;s address the last issue first.</p><h3 id=decoupling>Decoupling<a hidden class=anchor aria-hidden=true href=#decoupling>#</a></h3><p>To start the <code>SocketListener</code> from our test, we need to set up all the internals of the <code>server</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener(MessageReceiver(World()))
</span></span></code></pre></div><p>We&rsquo;ve introduced coupling<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> between the <code>client</code> module&rsquo;s test code and the internal structure of the <code>server</code>. This
means that if we change the internal structure of the server, we <strong>must</strong> change this code as well. That&rsquo;s not good. We
prefer our tests to be sensitive to the behaviour of the system, not to the structure of the system<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><p>Let&rsquo;s refactor step by step. First, we&rsquo;ll make a bit more explicit that the test needs to start the server, and needs to
know what port the server is running on. We&rsquo;ll introduce a <code>port</code> variable.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener(MessageReceiver(World()))
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>val</span> port = socketListener.port
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>val</span> socketClient = SocketClient(port)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>val</span> result = socketClient.send(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>assertThat(result).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span></code></pre></div><p>Then inline the <code>socketListener</code> variable.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>val</span> port = SocketListener(MessageReceiver(World())).port
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>val</span> socketClient = SocketClient(port)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>val</span> result = socketClient.send(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>assertThat(result).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span></code></pre></div><p>Now we can remove the knowledge about the <code>server</code> module&rsquo;s internals from the test method by extracting a method.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `invoke launch command with JSON message`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = startServerApplication()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> socketClient = SocketClient(port)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> result = socketClient.send(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    assertThat(result).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> startServerApplication() = SocketListener(MessageReceiver(World())).port
</span></span></code></pre></div><p>Finally, let&rsquo;s move the newly created <code>startServerApplication</code> function to the <code>server</code> module. I&rsquo;ve put it in a new
source file called <code>ServerApplication.kt</code> in the root package of the <code>server</code> module.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>package</span> nl.dirkgroot.robotworlds
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> startServerApplication() = SocketListener(MessageReceiver(World())).port
</span></span></code></pre></div><p>There, we&rsquo;ve encapsulated all knowledge about the internal structure of the <code>server</code> module into
the <code>startServerApplication</code> function. By moving said function to the <code>server</code> module, we completely decoupled the test
code in the <code>client</code> module from the internal structure of the <code>server</code> module.</p><h3 id=duplication>Duplication<a hidden class=anchor aria-hidden=true href=#duplication>#</a></h3><p>Let&rsquo;s look at the duplication we introduced. Look back at the <a href=#socket-client-class><code>SocketClient</code></a> class earlier in
this post, and compare it to what we have in <code>SocketListenerTest</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `handles a command`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener(MessageReceiver(World()))
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = socketListener.port
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertTimeoutPreemptively(Duration.ofSeconds(<span style=color:#ff0;font-weight:700>1</span>)) {
</span></span><span style=display:flex><span>        Socket(<span style=color:#0ff;font-weight:700>&#34;127.0.0.1&#34;</span>, port).use { socket -&gt;
</span></span><span style=display:flex><span>            sendLaunchCommand(socket)
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>val</span> response = receiveResponse(socket)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            assertThat(response).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> sendLaunchCommand(socket: Socket) {
</span></span><span style=display:flex><span>    socket.getOutputStream().writer().apply {
</span></span><span style=display:flex><span>        write(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span> + <span style=color:#0ff;font-weight:700>&#34;</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>)
</span></span><span style=display:flex><span>        flush()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> receiveResponse(socket: Socket) =
</span></span><span style=display:flex><span>    socket.getInputStream().bufferedReader().readLine()
</span></span></code></pre></div><p>Now this is not a 100% duplicate, but I think it&rsquo;s fairly obvious that both classes create a socket connection, send a
message and receive a response. If only we could use <code>SocketClient</code> in <code>SocketListenerTest</code>&mldr;</p><h3 id=simplification>Simplification<a hidden class=anchor aria-hidden=true href=#simplification>#</a></h3><p>I&rsquo;m tempted to introduce a new module, named <code>tcp-communication</code>, move <code>SocketClient</code> to that module, and use this new
module from the <code>client</code> and <code>server</code> module. But wait, why did we create separate modules for the server and the
client? I don&rsquo;t remember it being a very conscious decision. I guess I did it because I drew 2 separate containers in
the <a href=../01-walking-skeleton#what-is-robot-worlds>container diagram</a>. But now I think about it, having two separate
containers just means that there are two separate processes. This doesn&rsquo;t necessarily mean that they also need to be
separate executables. We could just as well create one executable which can be started either in client or in server
mode using a command-line switch.</p><p>Let&rsquo;s simplify the module structure, so we have just one module: <code>game</code>. I&rsquo;ll do it step by step, like this:</p><ol><li>Move all code from <code>client/src/main/kotlin</code> to <code>server/src/main/kotlin</code></li><li>Move all code from <code>client/src/test/kotlin</code> to <code>server/src/test/kotlin</code></li><li>Remove the <code>client</code> module</li><li>Rename the <code>server</code> to <code>game</code></li></ol><p>Now there&rsquo;s one thing I notice. In the <code>client</code> module I created a package called <code>nl.dirkgroot.robotworlds.client</code>, but
in the <code>server</code> module I put everything in the <code>nl.dirkgroot.robotworlds</code> package. Let&rsquo;s move the server code to
<code>nl.dirkgroot.robotworlds.server</code>. All tests still pass, so everything went well.</p><figure class=dg-figure-border><img loading=lazy src=game-module-structure.png></figure><h3 id=deduplication>Deduplication<a hidden class=anchor aria-hidden=true href=#deduplication>#</a></h3><p>Now that we have everything in one module, let&rsquo;s see what we can do about the duplication we created. We&rsquo;ll change
the <code>handles a command</code> test in <code>SocketListenerTest</code> so it uses <code>SocketClient</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `handles a command`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener(MessageReceiver(World()))
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = socketListener.port
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertTimeoutPreemptively(Duration.ofSeconds(<span style=color:#ff0;font-weight:700>1</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> response = SocketClient(port).send(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>        assertThat(response).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The test passes, so we can delete the <code>sendLaunchCommand</code> and <code>receiveResponse</code> methods from <code>SocketListenerTest</code>, as
those are not used anymore. Hmm, now there&rsquo;s still duplication left. This test is basically the same as the test we
wrote for <code>SocketClient</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `invoke launch command with JSON message`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = startServerApplication()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> socketClient = SocketClient(port)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> result = socketClient.send(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    assertThat(result).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The only differences are in how the socket listener is started and whether or not the test is timing out if no response
is received for more than 1 second. One of these tests can be deleted, for sure. There&rsquo;s no point in having two tests
test exactly the same thing.</p><p>I like the one with the timeout better, because it&rsquo;s a little more robust than the one without, so let&rsquo;s keep that one.
This means that we can delete the <code>SocketClientTest</code> class entirely, because it only contains the test we&rsquo;re going to
delete.</p><p>This leaves us with a bit of an awkward situation, because now <code>SocketListenerTest</code> is responsible for testing
both <code>SocketClient</code> and <code>SocketListener</code>. I don&rsquo;t think this is necessarily a bad thing. After all, to me, the &ldquo;unit&rdquo; in
unit testing is primarily a unit of behaviour - communication between client and server in this case - not a unit of
structure (a particular class or function). The awkwardness is in the names of the test class and the tests.</p><p>So let&rsquo;s just change the name of the test class to <code>ClientServerCommunicationTest</code>, and move it from the
<code>nl.dirkgroot.robotworlds.server</code> package to <code>nl.dirkgroot.robotworlds</code>. Also, let&rsquo;s change the initialisation part of
the two tests to use the <code>startServerApplication</code> function, and rename <code>handles a command</code>
to <code>client can send a command to server over a TCP socket</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `listens on free TCP port when no port is given`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = startServerApplication()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Socket(<span style=color:#0ff;font-weight:700>&#34;127.0.0.1&#34;</span>, port).use {
</span></span><span style=display:flex><span>        assertThat(<span style=color:#fff;font-weight:700>it</span>.isConnected).isTrue()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `client can send a command to server over a TCP socket`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = startServerApplication()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertTimeoutPreemptively(Duration.ofSeconds(<span style=color:#ff0;font-weight:700>1</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> response = SocketClient(port).send(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>        assertThat(response).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I think I like where this is going. Let&rsquo;s do a retrospective.</p><h2 id=retrospective>Retrospective<a hidden class=anchor aria-hidden=true href=#retrospective>#</a></h2><h3 id=horrible-sin>Horrible sin<a hidden class=anchor aria-hidden=true href=#horrible-sin>#</a></h3><p>I committed a horrible sin by copy/pasting code, but in my defense, we were in the <em>red</em> stage of the red/green/refactor
cycle. When we&rsquo;re in the red stage, our goal is to get to <em>green</em> as fast as possible, by any means necessary. And
that&rsquo;s what we did. In the <em>refactor</em> stage, we cleaned up our mess.</p><p>Working like this creates a very clear distinction between getting code to work and designing our code. Furthermore, as
you can see from this little project so far, most of the design work is done <em>after</em> we get some code to work. We did
very little design up front, and we did it just to get an idea of where we&rsquo;re heading.</p><p>Why does TDD work like this? Why do we refactor afterwards, instead of designing it &ldquo;the right way&rdquo; up front? In my
experience, no matter how much design you do up front, refactoring afterwards will always be necessary to keep the code
clean and well-factored. We just cannot foresee and account for every design issue we will face. When we&rsquo;re writing the
code, and when we&rsquo;re mindful of what we&rsquo;re creating, that&rsquo;s when the most valuable design insights occur, because the
code is right in front of us, and not in some fantasy in our minds.</p><h3 id=integration>Integration<a hidden class=anchor aria-hidden=true href=#integration>#</a></h3><p>By eliminating the duplication we introduced, we ended up with a test class which tests the communication between the
client and the server. We started out by testing the <code>SocketListener</code> by creating some stub client code, because that&rsquo;s
all we could do at that point. When we created the <code>SocketClient</code> class, we didn&rsquo;t need the stub code anymore and
replaced it with the actual client code. The result is what I would call an integration test.</p><p>I&rsquo;ve seen code bases where &ldquo;integration tests&rdquo; consisted of client code being tested by stubbing or mocking the server
in some way, and of server code being tested by stubbing the client. To me, this is not integration testing. If we want
to test whether two components integrate well, the best possible way to do that is by letting them actually &ldquo;talk&rdquo; to
each other. As we&rsquo;ve seen, this doesn&rsquo;t just result in testing the actual integration between components. It also
results in the elimination of duplication and all the risks that come with it.</p><p>Let&rsquo;s see if we can finish our walking skeleton next time, so we can start building some real end-to-end features.
Thanks for reading, see you next time!</p><p>PS: Here&rsquo;s the source code so far: <a href=https://github.com/dirkgroot/robot-worlds>https://github.com/dirkgroot/robot-worlds</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Or mocks, as most people call them. In reality, a mock is only one of many kinds of test doubles. Take a look at
the <a href=http://xunitpatterns.com/Test%20Double%20Patterns.html>Test Double patterns</a> on <a href=http://xunitpatterns.com>http://xunitpatterns.com</a> if you
want to know more about the terminology around test doubles.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>There&rsquo;s a lot more to say about end-to-end testing and testing strategy in general, but that&rsquo;s beyond the scope of
this series.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Watch Kent Beck <a href="https://youtu.be/3gib0hKYjB0?t=865">explain what coupling is</a>.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Again, watch Kent
Beck: <a href="https://youtu.be/3gib0hKYjB0?t=867">Test Desiderata 2/12 Tests Should be Structure-Insensitive</a>.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.dirkgroot.nl/tags/walking-skeleton/>walking-skeleton</a></li><li><a href=https://blog.dirkgroot.nl/tags/robot-worlds/>robot-worlds</a></li><li><a href=https://blog.dirkgroot.nl/tags/kotlin/>kotlin</a></li><li><a href=https://blog.dirkgroot.nl/tags/tdd/>tdd</a></li><li><a href=https://blog.dirkgroot.nl/tags/refactoring/>refactoring</a></li></ul><nav class=paginav><a class=next href=https://blog.dirkgroot.nl/posts/robot-worlds/02-communication/><span class=title>Next »</span><br><span>Robot Worlds 2: Communication</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.dirkgroot.nl>Dirk Groot</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=dg-extended-footer><div class=social-icons><a href=https://github.com/dirkgroot target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.linkedin.com/in/dirkgroot77 target=_blank rel="noopener noreferrer me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a><a href=https://twitter.com/dirk__groot target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>