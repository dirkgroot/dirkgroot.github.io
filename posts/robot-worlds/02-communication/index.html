<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Robot Worlds 2: Communication | Dirk Groot</title><meta name=keywords content="walking-skeleton,robot-worlds,kotlin,kotlin-serialization,tdd"><meta name=description content="
    Our walking skeleton is no more than an undead skull at the moment. Some more bones need to be added to make it a fully
fledged skeleton. Let&rsquo;s see if we can set up communication between the client and the server.
"><meta name=author content="Dirk Groot"><link rel=canonical href=https://blog.dirkgroot.nl/posts/robot-worlds/02-communication/><link crossorigin=anonymous href=/assets/css/stylesheet.7a9a232bd263c7c728764d673e311e223485d79aec414071c61373b461fdb01f.css integrity="sha256-epojK9Jjx8codk1nPjEeIjSF15rsQUBxxhNztGH9sB8=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.dirkgroot.nl/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.dirkgroot.nl/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.dirkgroot.nl/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.dirkgroot.nl/apple-touch-icon.png><link rel=mask-icon href=https://blog.dirkgroot.nl/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=/css/theme-overrides.css><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-TBE6V39YXJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TBE6V39YXJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Robot Worlds 2: Communication"><meta property="og:description" content="
    Our walking skeleton is no more than an undead skull at the moment. Some more bones need to be added to make it a fully
fledged skeleton. Let&rsquo;s see if we can set up communication between the client and the server.
"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.dirkgroot.nl/posts/robot-worlds/02-communication/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-18T13:53:03+00:00"><meta property="article:modified_time" content="2022-06-18T13:53:03+00:00"><meta property="og:see_also" content="https://blog.dirkgroot.nl/posts/robot-worlds/03-client/"><meta property="og:see_also" content="https://blog.dirkgroot.nl/posts/robot-worlds/01-walking-skeleton/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Robot Worlds 2: Communication"><meta name=twitter:description content="
    Our walking skeleton is no more than an undead skull at the moment. Some more bones need to be added to make it a fully
fledged skeleton. Let&rsquo;s see if we can set up communication between the client and the server.
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.dirkgroot.nl/posts/"},{"@type":"ListItem","position":3,"name":"Robot Worlds 2: Communication","item":"https://blog.dirkgroot.nl/posts/robot-worlds/02-communication/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Robot Worlds 2: Communication","name":"Robot Worlds 2: Communication","description":" Our walking skeleton is no more than an undead skull at the moment. Some more bones need to be added to make it a fully fledged skeleton. Let\u0026rsquo;s see if we can set up communication between the client and the server. ","keywords":["walking-skeleton","robot-worlds","kotlin","kotlin-serialization","tdd"],"articleBody":" Our walking skeleton is no more than an undead skull at the moment. Some more bones need to be added to make it a fully fledged skeleton. Let’s see if we can set up communication between the client and the server. Recap So where are we? In the first post in this series, we established a general idea of what the architecture of the game looks like, and we started creating a walking skeleton. We started at the bottom of the call stack, and we’re working our way up, step by step.\nCommunication Today, I would like to start setting up communication between the client and the server over a TCP socket. For that, we’ll need to serialize and deserialize the messages to/from JSON, and send JSON over a TCP socket. Let’s see if we can invoke the launch command by sending it in JSON format to the server. But first…\nReturning a result Looking at our launch command, I notice that it’s not returning a result.\nfun handleRequest(request: Request) { launchRobot() } According to the spec, every command must return a result, so let’s fix that first. Remember, for our walking skeleton, we return a very simple result:\n{ \"result\": \"OK\" } So let’s first change our test.\n@Test fun `execute a launch command`() { val world = World() val result = world.handleRequest(Request(command = \"launch\")) assertThat(world.robotCount).isEqualTo(1) assertThat(result).isEqualTo(CommandResult(result = \"OK\")) } This doesn’t compile, because the CommandResult class does not exist yet. Let’s create that first.\nclass CommandResult(result: String) Good enough for now. Now our test fails: expected:\u003c[nl.dirkgroot.robotworlds.CommandResult@750e2b97]\u003e but was:\u003c[kotlin.Unit]\u003e. That looks ugly. Let’s make it prettier:\ndata class CommandResult(val result: String) Data classes in Kotlin are a convenient way to create classes that are meant to hold data. Among other things, the Kotlin compiler automatically provides data classes with equals, hashCode and toString. The generatedtoString method makes the error message look nicer.\nThere, that’s a lot better: expected:\u003c[CommandResult(result=OK)]\u003e but was:\u003c[kotlin.Unit]\u003e. Now, let’s make the test pass.\nfun handleRequest(request: Request): CommandResult { launchRobot() return CommandResult(result = \"OK\") } (De)serialisation We’re still working on the game server. Now that we have a basic launch command working, let’s see what we need to add to the server so we can invoke it using a JSON message. Let’s ignore the TCP part for now and take a small step up the call stack. I think we’ll need a MessageReceiver which translates JSON messages to invocations of World::handleRequest.\nNo, let’s back off a little bit, and first make sure we can create a Request from JSON. If we have that in place, creating a MessageReceiver should be trivial.\n@Test fun `create a request from JSON`() { val request = Request.fromJSON(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(request).isEqualTo(Request(command = \"launch\")) } I’ll let IntelliJ generate a stub for Request::fromJSON.\nclass Request(command: String) { companion object { fun fromJSON(json: String): Request { TODO(\"Not yet implemented\") } } } Now our test fails, of course: An operation is not implemented: Not yet implemented. Let’s use Kotlin serialization to implement this.\nfun fromJSON(json: String): Request { return Json.decodeFromString(json) } Still fails: Serializer for class 'Request' is not found. Mark the class as @Serializable or provide the serializer explicitly. Request needs to be serializable.\n@Serializable class Request(command: String) Now we get a compiler error: “This class is not serializable automatically because it has primary constructor parameters that are not properties”. Okay, let’s make command a property.\n@Serializable class Request(val command: String) Now our test fails with an ugly message: expected:\u003c...robotworlds.Request@[4de025bf]\u003e but was:\u003c...robotworlds.Request@[538613b3]\u003e. I suspect this is because Request doesn’t have an equals implementation, so let’s upgrade it to a data class, like we did with CommandResult.\n@Serializable data class Request(val command: String) That was nice and easy. Now let’s move on to our MessageReceiver.\nLaunch with JSON First, we’ll try to invoke the launch command using a JSON message.\nclass MessageReceiverTest { @Test fun `invoke launch command with JSON message`() { val world = World() val messageReceiver = MessageReceiver(world) messageReceiver.receive(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(world.robotCount).isEqualTo(1) } } Doesn’t compile of course, so let’s create the MessageReceiver class, with a receive method.\nclass MessageReceiver(world: World) { fun receive(jsonMessage: String) { TODO(\"Not yet implemented\") } } Implement it to make the test pass. For this, we’ll have to make the constructor parameter world a class member.\nclass MessageReceiver(private val world: World) { fun receive(jsonMessage: String) { val request = Request.fromJSON(jsonMessage) world.handleRequest(request) } } I’d like receive to return the result in JSON format, so let’s make sure we can serialize CommandResult to JSON.\nclass CommandResultTest { @Test fun `serialize to JSON`() { val json = CommandResult(result = \"OK\").toJSON() assertThat(json).isEqualTo(\"\"\"{ \"result\": \"OK\" }\"\"\") } } Implement it in one fell swoop and use Kotlin serialization again.\n@Serializable data class CommandResult(val result: String) { fun toJSON(): String { return Json.encodeToString(this) } } The test fails: expected:\u003c\"{[ \"result\": \"OK\" ]}\"\u003e but was:\u003c\"{[\"result\":\"OK\"]}\"\u003e. Ah, apparently Json.encodeToString uses as few spaces as possible. Let’s adjust the test.\nassertThat(json).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") Done. Now let’s change MessageReceiver::receive to return a result in JSON format.\n@Test fun `invoke launch command with JSON message`() { val world = World() val messageReceiver = MessageReceiver(world) val result = messageReceiver.receive(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(world.robotCount).isEqualTo(1) assertThat(result).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } This fails with expected:\u003c[\"{\"result\":\"OK\"}\"]\u003e but was:\u003c[kotlin.Unit]\u003e. We’ll use the CommandResult returned by World::handleRequest as our return value.\nfun receive(jsonMessage: String): String { val request = Request.fromJSON(jsonMessage) return world.handleRequest(request).toJSON() } A little refactoring In the previous article, we already had a suspicion that World would eventually need to be split up. Now that we have a MessageReceiver in place, it’s becoming obvious that World::handleRequest is out of place. Remember, its job is to take a request, execute the requested command, and return a result. Its responsibility is focused on request and response messages. I think the primary responsibility of World should be to handle game logic. It shouldn’t need to worry about messages, and MessageReceiver seems like a much better place for that. So let’s move handleRequest to MessageReceiver.\nI’ll start by copy-pasting handleRequest to MessageReceiver, change receive to use MessageReceiver::handleRequest instead of World::handleRequest, and make it compile.\nfun receive(jsonMessage: String): String { val request = Request.fromJSON(jsonMessage) return handleRequest(request).toJSON() } fun handleRequest(request: Request): CommandResult { world.launchRobot() return CommandResult(result = \"OK\") } Tests still pass. Now we have two similar tests for the launch command, one in WorldTest and one in MessageReceiverTest. This is the one in WorldTest.\n@Test fun `execute a launch command`() { val world = World() val result = world.handleRequest(Request(command = \"launch\")) assertThat(world.robotCount).isEqualTo(1) assertThat(result).isEqualTo(CommandResult(result = \"OK\")) } And here’s the test in MessageReceiverTest.\n@Test fun `invoke launch command with JSON message`() { val world = World() val messageReceiver = MessageReceiver(world) val result = messageReceiver.receive(\"\"\"{ \"command\": \"launch\" }\"\"\") assertThat(world.robotCount).isEqualTo(1) assertThat(result).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } These tests are basically the same, except that the test for MessageReceiver is using JSON, and the test for World is using a Request object. Now, we could do two things: We could move the test in WorldTest to MessageReceiverTest and change it, so it uses MessageReceiver::handleRequest, or we could just delete the test in WorldTest. Let’s get rid of this duplication by deleting the test in WorldTest.\nTests still pass. Now that the duplicate test is gone, World::handleRequest is not used anywhere, so we can delete that as well. Finally, we can make MessageReceiver::handleRequest private, because it’s only used in MessageReceiver::receive.\nprivate fun handleRequest(request: Request): CommandResult { world.launchRobot() return CommandResult(result = \"OK\") } Are you being served? Now, let’s start setting up a TCP socket listener.\nclass SocketListenerTest { @Test fun `listens on free TCP port when no port is given`() { val socketListener = SocketListener() val port = socketListener.port val socket = Socket(\"127.0.0.1\", port) assertThat(socket.isConnected) .isTrue() socket.close() } } Create the SocketListener class.\nclass SocketListener { val port = 1 } And, as expected, our test fails: java.net.ConnectException: Connection refused. Making it pass is simple.\nclass SocketListener { private val serverSocket = ServerSocket(0) val port get() = serverSocket.localPort } We initialize the ServerSocket with port 0, so it will automatically choose an available port. If we pick a fixed port, there’s always a (small) risk that port is already taken, which could lead to flaky tests on the CI/CD pipeline. We don’t want flaky tests, so I’ll do whatever I can do to prevent that from happening.\nThe test code is a little verbose, so let’s make it more readable by using Kotlin’s handy dandy use extension.\n@Test fun `listens on free TCP port when no port is given`() { val socketListener = SocketListener() val port = socketListener.port Socket(\"127.0.0.1\", port).use { assertThat(it.isConnected).isTrue() } } That’s a lot better. Now let’s see if we can make it handle a request.\n@Test fun `handles a command`() { val socketListener = SocketListener() val port = socketListener.port Socket(\"127.0.0.1\", port).use { it.getOutputStream().writer().write(\"\"\"{ \"command\": \"launch\" }\"\"\") val response = it.getInputStream().bufferedReader().readLine() assertThat(response).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } } There’s a number of things that can be improved in this code, but let’s first see what happens. The SocketListener is not handling any messages, so the test waits indefinitely for a response. That’s not ideal. We want our test to fail, not to wait forever. Let’s fix that by using JUnit’s assertTimeoutPreemptively1.\n@Test fun `handles a command`() { val socketListener = SocketListener() val port: Int = socketListener.port assertTimeoutPreemptively(Duration.ofSeconds(1)) { Socket(\"127.0.0.1\", port).use { it.getOutputStream().writer().write(\"\"\"{ \"command\": \"launch\" }\"\"\") val response = it.getInputStream().bufferedReader().readLine() assertThat(response).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } } } Now the test properly fails. The timeout of 1 second is my arbitrary choice. It’s always risky to have these kinds of tests, because they tend to be flaky. For now, I’m okay with this, because I’ll probably only be running these tests on my developer laptop, and I don’t think it will be flaky. If it is, I’ll just run the test again, or increase the timeout.\nLet’s see if we can make the test pass. To do that, we’ll need to start a separate thread which handles requests in the background. We’ll also need to hand our SocketListener a MessageReceiver, so it will be able to handle the messages it receives. Let’s first change the instantiation of SocketListener in our test.\nval socketListener = SocketListener(MessageReceiver(World())) Now we need to change the SocketListener constructor.\nclass SocketListener(private val messageReceiver: MessageReceiver) And finally we need to start the thread and handle the request.\ninit { Thread { serverSocket.accept().use { val request = it.getInputStream().bufferedReader().readLine() val response = messageReceiver.receive(request) it.getOutputStream().writer().write(\"$response\\n\") } }.start() } This fails with a timeout. Ah, I forgot to send a newline after the request message. Let’s change that.\nit.getOutputStream().writer().write(\"\"\"{ \"command\": \"launch\" }\"\"\" + \"\\n\") It still fails. Apparently I’m doing something wrong, but it isn’t immediately obvious to me what that is. I see no other option than to use the debugger. Okay, so the SocketListener keeps blocking on val request = it.getInputStream().bufferedReader().readLine(). Do we need to flush the writer? Let’s try.\nit.getOutputStream().writer().apply { write(\"\"\"{ \"command\": \"launch\" }\"\"\" + \"\\n\") flush() } Te test still fails: expected:\u003c\"{\"result\":\"OK\"}\"\u003e but was:. It looks like we also need to flush in SocketListener.\nit.getOutputStream().writer().apply { write(\"$response\\n\") flush() } Yes, that does the trick. Now, our code can be improved a bit, so let’s do that. First of all, let’s make our test code a bit more readable.\n@Test fun `handles a command`() { val socketListener = SocketListener(MessageReceiver(World())) val port = socketListener.port assertTimeoutPreemptively(Duration.ofSeconds(1)) { Socket(\"127.0.0.1\", port).use { socket -\u003e sendLaunchCommand(socket) val response = receiveResponse(socket) assertThat(response).isEqualTo(\"\"\"{\"result\":\"OK\"}\"\"\") } } } private fun sendLaunchCommand(socket: Socket) { socket.getOutputStream().writer().apply { write(\"\"\"{ \"command\": \"launch\" }\"\"\" + \"\\n\") flush() } } private fun receiveResponse(socket: Socket) = socket.getInputStream().bufferedReader().readLine() Now it’s a bit clearer what our test is actually doing. Let’s do something similar in SocketListener.\ninit { Thread { serverSocket.accept().use { val request = receiveRequest(it) val response = messageReceiver.receive(request) sendResponse(it, response) } }.start() } private fun receiveRequest(socket: Socket) = socket.getInputStream().bufferedReader().readLine() private fun sendResponse(socket: Socket, response: String) { socket.getOutputStream().writer().apply { write(\"$response\\n\") flush() } } I think this is a good moment to call it a day, let’s do a little retrospective.\nRetro Everything went smooth, until we started messing with sockets. I don’t frequently work with sockets or input/output streams, so the need for flushing wasn’t immediately obvious to me. This is what typically happens when you’re working on the “edges” of the system. That’s where we need to deal with I/O, or databases, or queues, and often times non intuitive API’s.\nHumble object This is why I keep as much logic as possible separated from the code that has to deal with these kinds of API’s. That way, we maximize the amount of code that can easily be tested and understood. This is what’s called the Humble Object pattern. Our SocketListener is a humble object. Its only responsibilies are to accept connections, pass messages on to MessageReceiver and send the result back to the client.\nYAGNI Our SocketListener is far from done. It accepts one connection, handles one request and then stops. However, our goal is not to build a working feature, but to get just enough functionality working to allow us to start working on the first real feature. Our focus is not on functionality, but on setting up the general structure of the program and making sure it’s all testable.\nI’m relentlessly applying the YAGNI principle to get to our walking skeleton. I’m happily leaving out anything that is not strictly necessary for our goals. We’ll see if I’m going to regret doing that, but I think I won’t. Time will tell 😃.\nThanks for reading, and I’ll see you in the next one. You can find my source code on GitHub: https://github.com/dirkgroot/robot-worlds.\nThis assertion asserts that the lambda finishes before a timeout is exceeded. Read the the JavaDocs for more information. ↩︎\n","wordCount":"2254","inLanguage":"en","datePublished":"2022-06-18T13:53:03Z","dateModified":"2022-06-18T13:53:03Z","author":{"@type":"Person","name":"Dirk Groot"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.dirkgroot.nl/posts/robot-worlds/02-communication/"},"publisher":{"@type":"Organization","name":"Dirk Groot","logo":{"@type":"ImageObject","url":"https://blog.dirkgroot.nl/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.dirkgroot.nl accesskey=h title="Dirk Groot (Alt + H)">Dirk Groot</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.dirkgroot.nl/ title=Blog><span>Blog</span></a></li><li><a href=https://blog.dirkgroot.nl/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.dirkgroot.nl/series/ title=Series><span>Series</span></a></li><li><a href=https://blog.dirkgroot.nl/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.dirkgroot.nl/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.dirkgroot.nl/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.dirkgroot.nl>Home</a>&nbsp;»&nbsp;<a href=https://blog.dirkgroot.nl/posts/>Posts</a></div><h1 class=post-title>Robot Worlds 2: Communication</h1><div class=post-meta><span title='2022-06-18 13:53:03 +0000 UTC'>June 18, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Dirk Groot</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#recap aria-label=Recap>Recap</a></li><li><a href=#communication aria-label=Communication>Communication</a><ul><li><a href=#returning-a-result aria-label="Returning a result">Returning a result</a></li><li><a href=#deserialisation aria-label=(De)serialisation>(De)serialisation</a></li><li><a href=#launch-with-json aria-label="Launch with JSON">Launch with JSON</a></li><li><a href=#a-little-refactoring aria-label="A little refactoring">A little refactoring</a></li><li><a href=#are-you-being-served aria-label="Are you being served?">Are you being served?</a></li></ul></li><li><a href=#retro aria-label=Retro>Retro</a><ul><li><a href=#humble-object aria-label="Humble object">Humble object</a></li><li><a href=#yagni aria-label=YAGNI>YAGNI</a></li></ul></li></ul></div></details></div><div class=post-content><summary class=dg-summary>Our walking skeleton is no more than an undead skull at the moment. Some more bones need to be added to make it a fully
fledged skeleton. Let&rsquo;s see if we can set up communication between the client and the server.</summary><h2 id=recap>Recap<a hidden class=anchor aria-hidden=true href=#recap>#</a></h2><p>So where are we? In the <a href=../01-walking-skeleton>first post in this series</a>, we established a general idea of what the
architecture of the game looks like, and we started creating a walking skeleton. We started at the bottom of the call
stack, and we&rsquo;re working our way up, step by step.</p><h2 id=communication>Communication<a hidden class=anchor aria-hidden=true href=#communication>#</a></h2><p>Today, I would like to start setting up communication between the client and the server over a TCP socket. For that,
we&rsquo;ll need to serialize and deserialize the messages to/from JSON, and send JSON over a TCP socket. Let&rsquo;s see if we can
invoke the <code>launch</code> command by sending it in JSON format to the server. But first&mldr;</p><h3 id=returning-a-result>Returning a result<a hidden class=anchor aria-hidden=true href=#returning-a-result>#</a></h3><p>Looking at our launch command, I notice that it&rsquo;s not returning a result.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> handleRequest(request: Request) {
</span></span><span style=display:flex><span>    launchRobot()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>According to the spec, every command must
return a result, so let&rsquo;s fix that first. Remember, for our walking skeleton, we return a very simple result:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=font-weight:700>&#34;result&#34;</span>: <span style=color:#0ff;font-weight:700>&#34;OK&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So let&rsquo;s first change our test.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `execute a launch command`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> world = World()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> result = world.handleRequest(Request(command = <span style=color:#0ff;font-weight:700>&#34;launch&#34;</span>))
</span></span><span style=display:flex><span>    assertThat(world.robotCount).isEqualTo(<span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>    assertThat(result).isEqualTo(CommandResult(result = <span style=color:#0ff;font-weight:700>&#34;OK&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This doesn&rsquo;t compile, because the <code>CommandResult</code> class does not exist yet. Let&rsquo;s create that first.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> CommandResult(result: String)
</span></span></code></pre></div><p>Good enough for now. Now our test fails:
<code>expected:&lt;[nl.dirkgroot.robotworlds.CommandResult@750e2b97]> but was:&lt;[kotlin.Unit]></code>. That looks ugly. Let&rsquo;s make it
prettier:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>data</span> <span style=color:#fff;font-weight:700>class</span> CommandResult(<span style=color:#fff;font-weight:700>val</span> result: String)
</span></span></code></pre></div><p><a href=https://kotlinlang.org/docs/data-classes.html>Data classes</a> in Kotlin are a convenient way to create classes that are
meant to hold data. Among other things, the Kotlin compiler automatically provides data classes with <code>equals</code>,
<code>hashCode</code> and <code>toString</code>. The generated<code>toString</code> method makes the error message look nicer.</p><p>There, that&rsquo;s a lot better: <code>expected:&lt;[CommandResult(result=OK)]> but was:&lt;[kotlin.Unit]></code>. Now, let&rsquo;s make the
test pass.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> handleRequest(request: Request): CommandResult {
</span></span><span style=display:flex><span>    launchRobot()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> CommandResult(result = <span style=color:#0ff;font-weight:700>&#34;OK&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=deserialisation>(De)serialisation<a hidden class=anchor aria-hidden=true href=#deserialisation>#</a></h3><p>We&rsquo;re still working on the game server. Now that we have a basic <code>launch</code> command working, let&rsquo;s see what we need to add
to the server so we can invoke it using a JSON message. Let&rsquo;s ignore the TCP part for now and take a small step up the
call stack. I think we&rsquo;ll need a <code>MessageReceiver</code> which translates JSON messages to invocations of
<code>World::handleRequest</code>.</p><p>No, let&rsquo;s back off a little bit, and first make sure we can create a <code>Request</code> from JSON. If we have that in place,
creating a <code>MessageReceiver</code> should be trivial.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `create a request from JSON`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> request = Request.fromJSON(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    assertThat(request).isEqualTo(Request(command = <span style=color:#0ff;font-weight:700>&#34;launch&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;ll let IntelliJ generate a stub for <code>Request::fromJSON</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Request(command: String) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>companion</span> <span style=color:#fff;font-weight:700>object</span> {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>fun</span> fromJSON(json: String): Request {
</span></span><span style=display:flex><span>            TODO(<span style=color:#0ff;font-weight:700>&#34;Not yet implemented&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now our test fails, of course: <code>An operation is not implemented: Not yet implemented</code>. Let&rsquo;s use
<a href=https://kotlinlang.org/docs/serialization.html>Kotlin serialization</a> to implement this.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> fromJSON(json: String): Request {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> Json.decodeFromString(json)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Still fails: <code>Serializer for class 'Request' is not found. Mark the class as @Serializable or provide the serializer explicitly</code>. <code>Request</code> needs to be serializable.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Serializable
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Request(command: String)
</span></span></code></pre></div><p>Now we get a compiler error: &ldquo;This class is not serializable automatically because it has primary constructor parameters
that are not properties&rdquo;. Okay, let&rsquo;s make <code>command</code> a property.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Serializable
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Request(<span style=color:#fff;font-weight:700>val</span> command: String)
</span></span></code></pre></div><p>Now our test fails with an ugly
message: <code>expected:&lt;...robotworlds.Request@[4de025bf]> but was:&lt;...robotworlds.Request@[538613b3]></code>. I suspect this is
because <code>Request</code> doesn&rsquo;t have an <code>equals</code> implementation, so let&rsquo;s upgrade it to a <code>data class</code>, like we did
with <code>CommandResult</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Serializable
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>data</span> <span style=color:#fff;font-weight:700>class</span> Request(<span style=color:#fff;font-weight:700>val</span> command: String)
</span></span></code></pre></div><p>That was nice and easy. Now let&rsquo;s move on to our <code>MessageReceiver</code>.</p><h3 id=launch-with-json>Launch with JSON<a hidden class=anchor aria-hidden=true href=#launch-with-json>#</a></h3><p>First, we&rsquo;ll try to invoke the <code>launch</code> command using a JSON message.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> MessageReceiverTest {
</span></span><span style=display:flex><span>    @Test
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> `invoke launch command with JSON message`() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> world = World()
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> messageReceiver = MessageReceiver(world)
</span></span><span style=display:flex><span>        messageReceiver.receive(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>        assertThat(world.robotCount).isEqualTo(<span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Doesn&rsquo;t compile of course, so let&rsquo;s create the <code>MessageReceiver</code> class, with a <code>receive</code> method.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> MessageReceiver(world: World) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> receive(jsonMessage: String) {
</span></span><span style=display:flex><span>        TODO(<span style=color:#0ff;font-weight:700>&#34;Not yet implemented&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Implement it to make the test pass. For this, we&rsquo;ll have to make the constructor parameter <code>world</code> a class member.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> MessageReceiver(<span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>val</span> world: World) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> receive(jsonMessage: String) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> request = Request.fromJSON(jsonMessage)
</span></span><span style=display:flex><span>        world.handleRequest(request)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;d like <code>receive</code> to return the result in JSON format, so let&rsquo;s make sure we can serialize <code>CommandResult</code> to JSON.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> CommandResultTest {
</span></span><span style=display:flex><span>    @Test
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> `serialize to JSON`() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> json = CommandResult(result = <span style=color:#0ff;font-weight:700>&#34;OK&#34;</span>).toJSON()
</span></span><span style=display:flex><span>        assertThat(json).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;result&#34;: &#34;OK&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Implement it in one fell swoop and use Kotlin serialization again.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Serializable
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>data</span> <span style=color:#fff;font-weight:700>class</span> CommandResult(<span style=color:#fff;font-weight:700>val</span> result: String) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> toJSON(): String {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> Json.encodeToString(<span style=color:#fff;font-weight:700>this</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The test fails: <code>expected:&lt;"{[ "result": "OK" ]}"> but was:&lt;"{["result":"OK"]}"></code>. Ah, apparently <code>Json.encodeToString</code>
uses as few spaces as possible. Let&rsquo;s adjust the test.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>assertThat(json).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span></code></pre></div><p>Done. Now let&rsquo;s change <code>MessageReceiver::receive</code> to return a result in JSON format.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `invoke launch command with JSON message`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> world = World()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> messageReceiver = MessageReceiver(world)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> result = messageReceiver.receive(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    assertThat(world.robotCount).isEqualTo(<span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>    assertThat(result).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This fails with <code>expected:&lt;["{"result":"OK"}"]> but was:&lt;[kotlin.Unit]></code>. We&rsquo;ll use the <code>CommandResult</code> returned
by <code>World::handleRequest</code> as our return value.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> receive(jsonMessage: String): String {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> request = Request.fromJSON(jsonMessage)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> world.handleRequest(request).toJSON()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=a-little-refactoring>A little refactoring<a hidden class=anchor aria-hidden=true href=#a-little-refactoring>#</a></h3><p>In the previous article, we already had a suspicion that <code>World</code> would eventually need to be split up. Now that we have
a <code>MessageReceiver</code> in place, it&rsquo;s becoming obvious that <code>World::handleRequest</code> is out of place. Remember, its job is to
take a request, execute the requested command, and return a result. Its responsibility is focused on request and
response messages. I think the primary responsibility of <code>World</code> should be to handle game logic. It shouldn&rsquo;t need to
worry about messages, and <code>MessageReceiver</code> seems like a much better place for that. So let&rsquo;s move <code>handleRequest</code>
to <code>MessageReceiver</code>.</p><p>I&rsquo;ll start by copy-pasting <code>handleRequest</code> to <code>MessageReceiver</code>, change <code>receive</code> to
use <code>MessageReceiver::handleRequest</code> instead of <code>World::handleRequest</code>, and make it compile.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> receive(jsonMessage: String): String {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> request = Request.fromJSON(jsonMessage)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> handleRequest(request).toJSON()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> handleRequest(request: Request): CommandResult {
</span></span><span style=display:flex><span>    world.launchRobot()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> CommandResult(result = <span style=color:#0ff;font-weight:700>&#34;OK&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Tests still pass. Now we have two similar tests for the <code>launch</code> command, one in <code>WorldTest</code> and one
in <code>MessageReceiverTest</code>. This is the one in <code>WorldTest</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `execute a launch command`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> world = World()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> result = world.handleRequest(Request(command = <span style=color:#0ff;font-weight:700>&#34;launch&#34;</span>))
</span></span><span style=display:flex><span>    assertThat(world.robotCount).isEqualTo(<span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>    assertThat(result).isEqualTo(CommandResult(result = <span style=color:#0ff;font-weight:700>&#34;OK&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And here&rsquo;s the test in <code>MessageReceiverTest</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `invoke launch command with JSON message`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> world = World()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> messageReceiver = MessageReceiver(world)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> result = messageReceiver.receive(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    assertThat(world.robotCount).isEqualTo(<span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>    assertThat(result).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>These tests are basically the same, except that the test for <code>MessageReceiver</code> is using JSON, and the test for <code>World</code>
is using a <code>Request</code> object. Now, we could do two things: We could move the test in <code>WorldTest</code> to <code>MessageReceiverTest</code>
and change it, so it uses <code>MessageReceiver::handleRequest</code>, or we could just delete the test in <code>WorldTest</code>. Let&rsquo;s get
rid of this duplication by deleting the test in <code>WorldTest</code>.</p><p>Tests still pass. Now that the duplicate test is gone, <code>World::handleRequest</code> is not used anywhere, so we can delete
that as well. Finally, we can make <code>MessageReceiver::handleRequest</code> private, because it&rsquo;s only used
in <code>MessageReceiver::receive</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> handleRequest(request: Request): CommandResult {
</span></span><span style=display:flex><span>    world.launchRobot()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> CommandResult(result = <span style=color:#0ff;font-weight:700>&#34;OK&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=are-you-being-served>Are you being served?<a hidden class=anchor aria-hidden=true href=#are-you-being-served>#</a></h3><p>Now, let&rsquo;s start setting up a TCP socket listener.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> SocketListenerTest {
</span></span><span style=display:flex><span>    @Test
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> `listens on free TCP port when no port is given`() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener()
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> port = socketListener.port
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> socket = Socket(<span style=color:#0ff;font-weight:700>&#34;127.0.0.1&#34;</span>, port)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assertThat(socket.isConnected)
</span></span><span style=display:flex><span>            .isTrue()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        socket.close()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Create the <code>SocketListener</code> class.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> SocketListener {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = <span style=color:#ff0;font-weight:700>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And, as expected, our test fails: <code>java.net.ConnectException: Connection refused</code>. Making it pass is simple.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> SocketListener {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>val</span> serverSocket = ServerSocket(<span style=color:#ff0;font-weight:700>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port <span style=color:#fff;font-weight:700>get</span>() = serverSocket.localPort
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We initialize the <code>ServerSocket</code> with port <code>0</code>, so it will automatically choose an available port. If we pick a fixed
port, there&rsquo;s always a (small) risk that port is already taken, which could lead to flaky tests on the CI/CD pipeline.
We don&rsquo;t want flaky tests, so I&rsquo;ll do whatever I can do to prevent that from happening.</p><p>The test code is a little verbose, so let&rsquo;s make it more readable by using Kotlin&rsquo;s handy
dandy <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html><code>use</code></a> extension.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `listens on free TCP port when no port is given`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = socketListener.port
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Socket(<span style=color:#0ff;font-weight:700>&#34;127.0.0.1&#34;</span>, port).use {
</span></span><span style=display:flex><span>        assertThat(<span style=color:#fff;font-weight:700>it</span>.isConnected).isTrue()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s a lot better. Now let&rsquo;s see if we can make it handle a request.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `handles a command`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = socketListener.port
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Socket(<span style=color:#0ff;font-weight:700>&#34;127.0.0.1&#34;</span>, port).use {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>it</span>.getOutputStream().writer().write(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> response = <span style=color:#fff;font-weight:700>it</span>.getInputStream().bufferedReader().readLine()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assertThat(response).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There&rsquo;s a number of things that can be improved in this code, but let&rsquo;s first see what happens. The <code>SocketListener</code> is
not handling any messages, so the test waits indefinitely for a response. That&rsquo;s not ideal. We want our test to fail,
not to wait forever. Let&rsquo;s fix that by using JUnit&rsquo;s <code>assertTimeoutPreemptively</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `handles a command`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener()
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port: Int = socketListener.port
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertTimeoutPreemptively(Duration.ofSeconds(<span style=color:#ff0;font-weight:700>1</span>)) {
</span></span><span style=display:flex><span>        Socket(<span style=color:#0ff;font-weight:700>&#34;127.0.0.1&#34;</span>, port).use {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>it</span>.getOutputStream().writer().write(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>val</span> response = <span style=color:#fff;font-weight:700>it</span>.getInputStream().bufferedReader().readLine()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            assertThat(response).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now the test properly fails. The timeout of 1 second is my arbitrary choice. It&rsquo;s always risky to have these kinds of
tests, because they tend to be flaky. For now, I&rsquo;m okay with this, because I&rsquo;ll probably only be running these tests on
my developer laptop, and I don&rsquo;t think it will be flaky. If it is, I&rsquo;ll just run the test again, or increase the
timeout.</p><p>Let&rsquo;s see if we can make the test pass. To do that, we&rsquo;ll need to start a separate thread which handles requests in the
background. We&rsquo;ll also need to hand our <code>SocketListener</code> a <code>MessageReceiver</code>, so it will be able to handle the messages
it receives. Let&rsquo;s first change the instantiation of <code>SocketListener</code> in our test.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener(MessageReceiver(World()))
</span></span></code></pre></div><p>Now we need to change the <code>SocketListener</code> constructor.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> SocketListener(<span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>val</span> messageReceiver: MessageReceiver)
</span></span></code></pre></div><p>And finally we need to start the thread and handle the request.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>init</span> {
</span></span><span style=display:flex><span>    Thread {
</span></span><span style=display:flex><span>        serverSocket.accept().use {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>val</span> request = <span style=color:#fff;font-weight:700>it</span>.getInputStream().bufferedReader().readLine()
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>val</span> response = messageReceiver.receive(request)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>it</span>.getOutputStream().writer().write(<span style=color:#0ff;font-weight:700>&#34;</span><span style=color:#0ff;font-weight:700>$response</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }.start()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This fails with a timeout. Ah, I forgot to send a newline after the request message. Let&rsquo;s change that.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>it</span>.getOutputStream().writer().write(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span> + <span style=color:#0ff;font-weight:700>&#34;</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>)
</span></span></code></pre></div><p>It still fails. Apparently I&rsquo;m doing something wrong, but it isn&rsquo;t immediately obvious to me what that is. I see no
other option than to use the debugger. Okay, so the <code>SocketListener</code> keeps blocking
on <code>val request = it.getInputStream().bufferedReader().readLine()</code>. Do we need to <code>flush</code> the writer? Let&rsquo;s try.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>it</span>.getOutputStream().writer().apply {
</span></span><span style=display:flex><span>    write(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span> + <span style=color:#0ff;font-weight:700>&#34;</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>)
</span></span><span style=display:flex><span>    flush()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Te test still fails: <code>expected:&lt;"{"result":"OK"}"> but was:&lt;null></code>. It looks like we also need to flush
in <code>SocketListener</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>it</span>.getOutputStream().writer().apply {
</span></span><span style=display:flex><span>    write(<span style=color:#0ff;font-weight:700>&#34;</span><span style=color:#0ff;font-weight:700>$response</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>)
</span></span><span style=display:flex><span>    flush()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yes, that does the trick. Now, our code can be improved a bit, so let&rsquo;s do that. First of all, let&rsquo;s make our test code
a bit more readable.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `handles a command`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> socketListener = SocketListener(MessageReceiver(World()))
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> port = socketListener.port
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertTimeoutPreemptively(Duration.ofSeconds(<span style=color:#ff0;font-weight:700>1</span>)) {
</span></span><span style=display:flex><span>        Socket(<span style=color:#0ff;font-weight:700>&#34;127.0.0.1&#34;</span>, port).use { socket -&gt;
</span></span><span style=display:flex><span>            sendLaunchCommand(socket)
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>val</span> response = receiveResponse(socket)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            assertThat(response).isEqualTo(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{&#34;result&#34;:&#34;OK&#34;}&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> sendLaunchCommand(socket: Socket) {
</span></span><span style=display:flex><span>    socket.getOutputStream().writer().apply {
</span></span><span style=display:flex><span>        write(<span style=color:#0ff;font-weight:700>&#34;&#34;&#34;{ &#34;command&#34;: &#34;launch&#34; }&#34;&#34;&#34;</span> + <span style=color:#0ff;font-weight:700>&#34;</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>)
</span></span><span style=display:flex><span>        flush()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> receiveResponse(socket: Socket) =
</span></span><span style=display:flex><span>    socket.getInputStream().bufferedReader().readLine()
</span></span></code></pre></div><p>Now it&rsquo;s a bit clearer what our test is actually doing. Let&rsquo;s do something similar in <code>SocketListener</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>init</span> {
</span></span><span style=display:flex><span>    Thread {
</span></span><span style=display:flex><span>        serverSocket.accept().use {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>val</span> request = receiveRequest(<span style=color:#fff;font-weight:700>it</span>)
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>val</span> response = messageReceiver.receive(request)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            sendResponse(<span style=color:#fff;font-weight:700>it</span>, response)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }.start()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> receiveRequest(socket: Socket) =
</span></span><span style=display:flex><span>    socket.getInputStream().bufferedReader().readLine()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>fun</span> sendResponse(socket: Socket, response: String) {
</span></span><span style=display:flex><span>    socket.getOutputStream().writer().apply {
</span></span><span style=display:flex><span>        write(<span style=color:#0ff;font-weight:700>&#34;</span><span style=color:#0ff;font-weight:700>$response</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>)
</span></span><span style=display:flex><span>        flush()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I think this is a good moment to call it a day, let&rsquo;s do a little retrospective.</p><h2 id=retro>Retro<a hidden class=anchor aria-hidden=true href=#retro>#</a></h2><p>Everything went smooth, until we started messing with sockets. I don&rsquo;t frequently work with sockets or input/output
streams, so the need for flushing wasn&rsquo;t immediately obvious to me. This is what typically happens when you&rsquo;re working
on the &ldquo;edges&rdquo; of the system. That&rsquo;s where we need to deal with I/O, or databases, or queues, and often times non
intuitive API&rsquo;s.</p><h3 id=humble-object>Humble object<a hidden class=anchor aria-hidden=true href=#humble-object>#</a></h3><p>This is why I keep as much logic as possible separated from the code that has to deal with these kinds of API&rsquo;s. That
way, we maximize the amount of code that can easily be tested and understood. This is what&rsquo;s called the
<a href=https://martinfowler.com/bliki/HumbleObject.html>Humble Object</a> pattern. Our <code>SocketListener</code> is a humble object. Its
only responsibilies are to accept connections, pass messages on to <code>MessageReceiver</code> and send the result back to the
client.</p><h3 id=yagni>YAGNI<a hidden class=anchor aria-hidden=true href=#yagni>#</a></h3><p>Our <code>SocketListener</code> is far from done. It accepts one connection, handles one request and then stops. However, our goal
is not to build a working feature, but to get just enough functionality working to allow us to start working on the
first real feature. Our focus is not on functionality, but on setting up the general structure of the program and making
sure it&rsquo;s all testable.</p><p>I&rsquo;m relentlessly applying the <a href=https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>YAGNI principle</a> to get to our
walking skeleton. I&rsquo;m happily leaving out anything that is not strictly necessary for our goals. We&rsquo;ll see if I&rsquo;m going
to regret doing that, but I think I won&rsquo;t. Time will tell 😃.</p><p>Thanks for reading, and I&rsquo;ll see you in the next one. You can find my source code on
GitHub: <a href=https://github.com/dirkgroot/robot-worlds>https://github.com/dirkgroot/robot-worlds</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This assertion asserts that the lambda finishes before a timeout is exceeded. Read the
the <a href=https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html#assertTimeoutPreemptively(java.time.Duration,org.junit.jupiter.api.function.Executable)>JavaDocs</a>
for more information.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.dirkgroot.nl/tags/walking-skeleton/>walking-skeleton</a></li><li><a href=https://blog.dirkgroot.nl/tags/robot-worlds/>robot-worlds</a></li><li><a href=https://blog.dirkgroot.nl/tags/kotlin/>kotlin</a></li><li><a href=https://blog.dirkgroot.nl/tags/kotlin-serialization/>kotlin-serialization</a></li><li><a href=https://blog.dirkgroot.nl/tags/tdd/>tdd</a></li></ul><nav class=paginav><a class=prev href=https://blog.dirkgroot.nl/posts/robot-worlds/03-client/><span class=title>« Prev</span><br><span>Robot Worlds 3: Client</span></a>
<a class=next href=https://blog.dirkgroot.nl/posts/robot-worlds/01-walking-skeleton/><span class=title>Next »</span><br><span>Robot Worlds 1: Walking Skeleton</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.dirkgroot.nl>Dirk Groot</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=dg-extended-footer><div class=social-icons><a href=https://github.com/dirkgroot target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.linkedin.com/in/dirkgroot77 target=_blank rel="noopener noreferrer me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a><a href=https://twitter.com/dirk__groot target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>