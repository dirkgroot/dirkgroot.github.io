<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Robot Worlds 1: Walking Skeleton | Dirk Groot</title><meta name=keywords content="walking-skeleton,robot-worlds,kotlin,tdd"><meta name=description content="
    
Let's make a game! I have a big graveyard of unfinished hobby projects, so I
have no idea how far I'll get. But as long as learning ensues, I'm fine with
that.

"><meta name=author content="Dirk Groot"><link rel=canonical href=https://blog.dirkgroot.nl/posts/robot-worlds/01-walking-skeleton/><link crossorigin=anonymous href=/assets/css/stylesheet.7a9a232bd263c7c728764d673e311e223485d79aec414071c61373b461fdb01f.css integrity="sha256-epojK9Jjx8codk1nPjEeIjSF15rsQUBxxhNztGH9sB8=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.dirkgroot.nl/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.dirkgroot.nl/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.dirkgroot.nl/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.dirkgroot.nl/apple-touch-icon.png><link rel=mask-icon href=https://blog.dirkgroot.nl/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=/css/code.css><link rel=stylesheet href=/css/style.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-TBE6V39YXJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-TBE6V39YXJ',{anonymize_ip:!1})}</script><meta property="og:title" content="Robot Worlds 1: Walking Skeleton"><meta property="og:description" content="
    
Let's make a game! I have a big graveyard of unfinished hobby projects, so I
have no idea how far I'll get. But as long as learning ensues, I'm fine with
that.

"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.dirkgroot.nl/posts/robot-worlds/01-walking-skeleton/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-14T20:14:13+00:00"><meta property="article:modified_time" content="2022-06-14T20:14:13+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Robot Worlds 1: Walking Skeleton"><meta name=twitter:description content="
    
Let's make a game! I have a big graveyard of unfinished hobby projects, so I
have no idea how far I'll get. But as long as learning ensues, I'm fine with
that.

"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.dirkgroot.nl/posts/"},{"@type":"ListItem","position":3,"name":"Robot Worlds 1: Walking Skeleton","item":"https://blog.dirkgroot.nl/posts/robot-worlds/01-walking-skeleton/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Robot Worlds 1: Walking Skeleton","name":"Robot Worlds 1: Walking Skeleton","description":" Let's make a game! I have a big graveyard of unfinished hobby projects, so I have no idea how far I'll get. But as long as learning ensues, I'm fine with that. ","keywords":["walking-skeleton","robot-worlds","kotlin","tdd"],"articleBody":" Let's make a game! I have a big graveyard of unfinished hobby projects, so I have no idea how far I'll get. But as long as learning ensues, I'm fine with that. Intro I created this blog site 6 months ago, so I guess it‚Äôs about time to actually start writing üôÑ. Here goes nothing!\nGeepaw Hill and Ron Jeffries both started a (v|b)log series on a fun programming exercise called Robot Worlds. From what I understand from these blogs, this exercise is part of an education offered by WeThinkCode_, which helps young South Africans train their digital skills.\nI really like doing these kinds of exercises, mainly because they are an excellent way of practicing my test-driven development skills, and a nice programming challenge in general. So let‚Äôs give it a go, shall we?\nYou can view the source code on GitHub: https://github.com/dirkgroot/robot-worlds.\nWhat is Robot Worlds? Robot Worlds is a multiplayer game in which the player controls a robot in a world full of obstacles, pits, and other robots. Robots can move around, scan their surroundings, shoot, and place mines. It consists of a client and a server, which communicate over a TCP socket connection, using messages in JSON format. Check out Hill‚Äôs GitHub repository for the specifications.\nThe container diagram1 below shows my current understanding of the architecture of the game.\nWalking skeleton Both Hill and Jeffries start out by building what‚Äôs called a ‚Äúwalking skeleton‚Äù, and I‚Äôll be doing that as well. The term ‚Äúwalking skeleton‚Äù was coined by Alistair Cockburn, and the GOOS book describes it as follows:\nA ‚Äúwalking skeleton‚Äù is an implementation of the thinnest possible slice of real functionality that we can automatically build, deploy, and test end-to-end. It should include just enough of the automation, the major components, and communication mechanisms to allow us to start working on the first feature.\nHill and Jeffries have also given some valuable insights about what a walking skeleton is, and why it‚Äôs so useful. Check out their articles, they are really good!\nMy plan is to follow the definition of the GOOS book rather closely. This means I‚Äôll create a client and a server application with just enough functionality to justify their existence and the need for communication between the client and the server.\nLet‚Äôs get started! Project setup First things first, let‚Äôs set up a basic project. I‚Äôll be using Kotlin as my programming language, and IntelliJ IDEA as my IDE. I‚Äôve set up a multi-module Gradle project with 2 modules to start with: client and server:\nrobot-worlds |... |- client | |- src/main/kotlin | |- src/test/kotlin | |- build.gradle.kts |... |- server | |- src/main/kotlin | |- src/test/kotlin | |- build.gradle.kts |... |- settings.gradle.kts Launch! So, what‚Äôs the ‚Äúthinnest possible slice of real functionality‚Äù we could implement in our walking skeleton? Launching a robot into the world seems like a good candidate. To launch a robot into the world, the client must send a launch command to the server with some arguments, describing the robot it wants to launch. If all is well, the server then responds with a message containing an OK result and the current state of the robot (position, orientation, etc).\nI‚Äôd like to make this slice even thinner. Let‚Äôs start by implementing a very minimal version of the launch command and response. We‚Äôre leaving out the arguments from the command, and the state from the response. Furthermore, we‚Äôll only implement the happy flow.\nThis is how the first version of the launch command will look:\n{ \"command\": \"launch\" } The response will look like this:\n{ \"result\": \"OK\" } So, where to begin? Although this is indeed a very thin slice of real functionality, it‚Äôs still functionality that requires all major parts of the application to be in place. That way we can test it end-to-end. We need a client and a server, both need some kind of user interface, and the client needs to send commands to the server over a TCP socket.\nLet‚Äôs start from the bottom of the call stack, and step by step work our way upwards. What do I mean by this? This sequence diagram is a rough sketch of the call stack I currently have in mind.\nJust rotate your screen 90 degrees clockwise, and you‚Äôll see what I mean. The top of the call stack is where everything starts: the Player. With every arrow we dive a level deeper into the call stack, until we arrive at World. So the bottom of the call stack in this case is World.\nWorld-class Let‚Äôs start nice and simple. First, write a test.\nclass WorldTest { @Test fun `no robots in a new world`() { val world = World() assertThat(world.robotCount).isZero() } } Making it pass is easy.\nclass World { val robotCount: Int = 0 } For our slice, we need a way to launch a robot into the world.\n@Test fun `launch a robot into the world`() { val world = World() world.launchRobot() assertThat(world.robotCount).isEqualTo(1) } We don‚Äôt have a launchRobot function yet, so make it compile first.\nclass World { val robotCount: Int = 0 fun launchRobot() { } } Our test fails, of course: expected:\u003c[1]\u003e but was:\u003c[0]\u003e. Let‚Äôs make it pass. We‚Äôll make the robotCount a var instead of a val, to be able to update it‚Äôs value.\nvar robotCount: Int = 0 fun launchRobot() { robotCount++ } Now the robotCount property can be updated by everyone. Let‚Äôs make the setter private, so only World can update it.\nvar robotCount: Int = 0 private set Our tests still pass, so I guess the head of our walking skeleton is done üíÄ. It doesn‚Äôt have much of a brain yet, but with the amount of intelligence it currently has, I‚Äôd call it ‚Äúundead‚Äù.\nRequest to launch Looking at the protocol specification, we can see that every interaction between client and server is initiated by the client. The communication style is request-response. The client requests the server to execute a command, and the server replies with a result.\nSo, if we move one step up the call stack from World::launch, what would we need? I think it‚Äôs a function that takes a request and executes the requested command. Let‚Äôs implement this without worrying about (de)serializing from/to JSON yet. We‚Äôll start by adding a test to WorldTest.\n@Test fun `execute a launch command`() { val world = World() world.handleRequest(Request(command = \"launch\")) assertThat(world.robotCount).isEqualTo(1) } This doesn‚Äôt compile, because we don‚Äôt have a Request class, and World doesn‚Äôt have a handleRequest method. Let‚Äôs start by letting IntelliJ generate a Request class for us (I‚Äôm lazy).\nclass Request(command: String) Easy. Now, IntelliJ can generate the World::handleRequest method as well.\nfun handleRequest(request: Request) { } Now our test compiles, but it fails: expected:\u003c[1]\u003e but was:\u003c[0]\u003e, so let‚Äôs make it pass.\nfun handleRequest(request: Request) { launchRobot() } Yep, that‚Äôs all we need for now.\nReally? Remember the description from the GOOS book earlier in this post. Our goal here is not to build an entire feature:\n[‚Ä¶] It should include just enough of the automation, the major components, and communication mechanisms to allow us to start working on the first feature.\nWe just want to get all the stuff in place that we need to build and test our first feature end-to-end. In a real-world project this would typically include setting up build scripts, CI/CD, deployment to DTAP environments, etc. By doing this first, we benefit from having all this from the very start. Immediately, we have everything in place to make sure that every bit of functionality we add is well-tested, well-factored and potentially shippable.\nSummary We started out by drawing a little architecture diagram to get an overview of the major parts of the game that we‚Äôre building. Later on, the sequence diagram helped us choose a starting point for writing some actual code. I feel like that was just enough ‚Äúdesign up front‚Äù to get me started.\nWe got some of the boring project set up stuff out of the way. The project is set up and a tiny part of a tiny slice of functionality is in place. The World class will almost certainly be split up into the actual game logic and one or more other classes which handle requests from the client. We could have chosen to do that right now, but we can also do it later. I don‚Äôt think it‚Äôs really important right now.\nFor now, our goal is to put the major components in place, and World is one of them. The next steps up the call stack will most likely be the TCP socket connection and (de)serialization of messages.\nSo there it is, 6 months after setting it up, this blog has finally officially been kicked off. I hope you enjoyed my first post. I certainly enjoyed writing it. Stay tuned for the next one!\nThe container diagram is one of the 4 core diagrams of the C4 model for visualising software architecture.¬†‚Ü©Ô∏é\n","wordCount":"1493","inLanguage":"en","datePublished":"2022-06-14T20:14:13Z","dateModified":"2022-06-14T20:14:13Z","author":{"@type":"Person","name":"Dirk Groot"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.dirkgroot.nl/posts/robot-worlds/01-walking-skeleton/"},"publisher":{"@type":"Organization","name":"Dirk Groot","logo":{"@type":"ImageObject","url":"https://blog.dirkgroot.nl/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.dirkgroot.nl accesskey=h title="Dirk Groot (Alt + H)">Dirk Groot</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.dirkgroot.nl/ title=Blog><span>Blog</span></a></li><li><a href=https://blog.dirkgroot.nl/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.dirkgroot.nl/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.dirkgroot.nl/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.dirkgroot.nl/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.dirkgroot.nl>Home</a>&nbsp;¬ª&nbsp;<a href=https://blog.dirkgroot.nl/posts/>Posts</a></div><h1 class=post-title>Robot Worlds 1: Walking Skeleton</h1><div class=post-meta><span title='2022-06-14 20:14:13 +0000 UTC'>June 14, 2022</span>&nbsp;¬∑&nbsp;8 min&nbsp;¬∑&nbsp;Dirk Groot</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#intro aria-label=Intro>Intro</a></li><li><a href=#what-is-robot-worlds aria-label="What is Robot Worlds?">What is Robot Worlds?</a></li><li><a href=#walking-skeleton aria-label="Walking skeleton">Walking skeleton</a></li><li><a href=#lets-get-started aria-label="Let&amp;rsquo;s get started!">Let&rsquo;s get started!</a><ul><li><a href=#project-setup aria-label="Project setup">Project setup</a></li><li><a href=#launch aria-label=Launch!>Launch!</a></li><li><a href=#so-where-to-begin aria-label="So, where to begin?">So, where to begin?</a></li><li><a href=#world-class aria-label=World-class>World-class</a></li><li><a href=#request-to-launch aria-label="Request to launch">Request to launch</a></li><li><a href=#really aria-label=Really?>Really?</a></li></ul></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></div></details></div><div class=post-content><summary>Let's make a game! I have a big graveyard of unfinished hobby projects, so I
have no idea how far I'll get. But as long as learning ensues, I'm fine with
that.</summary><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>I created this blog site 6 months ago, so I guess it&rsquo;s about time to actually
start writing üôÑ. Here goes nothing!</p><p><a href=https://www.geepawhill.org/series/robot-worlds/>Geepaw Hill</a> and
<a href=https://ronjeffries.com/categories/robot/>Ron Jeffries</a> both started a
(v|b)log series on a fun programming exercise called Robot Worlds. From what I
understand from these blogs, this exercise is part of an education offered
by <a href=https://www.wethinkcode.co.za/>WeThinkCode_</a>, which helps young South
Africans train their digital skills.</p><p>I really like doing these kinds of exercises, mainly because they are an
excellent way of practicing my test-driven development skills, and a nice
programming challenge in general. So let&rsquo;s give it a go, shall we?</p><p>You can view the source code on
GitHub: <a href=https://github.com/dirkgroot/robot-worlds>https://github.com/dirkgroot/robot-worlds</a>.</p><h2 id=what-is-robot-worlds>What is Robot Worlds?<a hidden class=anchor aria-hidden=true href=#what-is-robot-worlds>#</a></h2><p>Robot Worlds is a multiplayer game in which the player controls a robot in a
world full of obstacles, pits, and other robots. Robots can move around, scan
their surroundings, shoot, and place mines. It consists of a client and a
server, which communicate over a TCP socket connection, using messages in JSON
format. Check out
<a href=https://github.com/GeePawHill/robot-worlds/tree/main/notes>Hill&rsquo;s GitHub repository</a>
for the specifications.</p><p>The <em>container diagram</em><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> below shows my current understanding of the
architecture of the game.</p><figure class=figure-border><img loading=lazy src=container.svg></figure><h2 id=walking-skeleton>Walking skeleton<a hidden class=anchor aria-hidden=true href=#walking-skeleton>#</a></h2><p>Both Hill and Jeffries start out by building what&rsquo;s called a &ldquo;walking skeleton&rdquo;,
and I&rsquo;ll be doing that as well. The term &ldquo;walking skeleton&rdquo; was coined by
<a href=https://twitter.com/TotherAlistair/>Alistair Cockburn</a>, and the
<a href=https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627>GOOS book</a>
describes it as follows:</p><blockquote><p>A ‚Äúwalking skeleton‚Äù is an implementation of the thinnest possible slice of
real functionality that we can automatically build, deploy, and test
end-to-end. It should include just enough of the automation, the
major components, and communication mechanisms to allow us to start working on
the first feature.</p></blockquote><p>Hill and Jeffries have also given some valuable insights about what a walking
skeleton is, and why it&rsquo;s so useful. Check out their articles, they are really
good!</p><p>My plan is to follow the definition of the GOOS book rather closely. This means
I&rsquo;ll create a client and a server application with just enough functionality to
justify their existence and the need for communication between the client and
the server.</p><h2 id=lets-get-started>Let&rsquo;s get started!<a hidden class=anchor aria-hidden=true href=#lets-get-started>#</a></h2><h3 id=project-setup>Project setup<a hidden class=anchor aria-hidden=true href=#project-setup>#</a></h3><p>First things first, let&rsquo;s set up a basic project. I&rsquo;ll be using Kotlin as my
programming language, and IntelliJ IDEA as my IDE. I&rsquo;ve set up a multi-module
Gradle project with 2 modules to start with: <code>client</code> and <code>server</code>:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>robot-worlds
</span></span><span style=display:flex><span>|...
</span></span><span style=display:flex><span>|- client
</span></span><span style=display:flex><span>|  |- src/main/kotlin
</span></span><span style=display:flex><span>|  |- src/test/kotlin
</span></span><span style=display:flex><span>|  |- build.gradle.kts
</span></span><span style=display:flex><span>|...
</span></span><span style=display:flex><span>|- server
</span></span><span style=display:flex><span>|  |- src/main/kotlin
</span></span><span style=display:flex><span>|  |- src/test/kotlin
</span></span><span style=display:flex><span>|  |- build.gradle.kts
</span></span><span style=display:flex><span>|...
</span></span><span style=display:flex><span>|- settings.gradle.kts
</span></span></code></pre></div><h3 id=launch>Launch!<a hidden class=anchor aria-hidden=true href=#launch>#</a></h3><p>So, what&rsquo;s the &ldquo;thinnest possible slice of real functionality&rdquo; we could
implement in our walking skeleton? Launching a robot into the world seems like a
good candidate. To launch a robot into the world, the client must send
a <code>launch</code> command to the server with some arguments, describing the robot it
wants to launch. If all is well, the server then responds with a message
containing an <code>OK</code> result and the current state of the robot (position,
orientation, etc).</p><p>I&rsquo;d like to make this slice even thinner. Let&rsquo;s start by implementing a very
minimal version of the <code>launch</code> command and response. We&rsquo;re leaving out the
arguments from the command, and the state from the response. Furthermore, we&rsquo;ll
only implement the happy flow.</p><p>This is how the first version of the <code>launch</code> command will look:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=font-weight:700>&#34;command&#34;</span>: <span style=color:#0ff;font-weight:700>&#34;launch&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The response will look like this:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=font-weight:700>&#34;result&#34;</span>: <span style=color:#0ff;font-weight:700>&#34;OK&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=so-where-to-begin>So, where to begin?<a hidden class=anchor aria-hidden=true href=#so-where-to-begin>#</a></h3><p>Although this is indeed a very thin slice of real functionality, it&rsquo;s still
functionality that requires all major parts of the application to be in place.
That way we can test it end-to-end. We need a client and a server, both need
some kind of user interface, and the client needs to send commands to the server
over a TCP socket.</p><p>Let&rsquo;s start from the bottom of the call stack, and step by step work our way
upwards. What do I mean by this? This sequence diagram is a rough sketch of the
call stack I currently have in mind.</p><figure class=figure-border><img loading=lazy src=launch-sequence.svg></figure><p>Just rotate your screen 90 degrees clockwise, and you&rsquo;ll see what I mean. The
top of the call stack is where everything starts: the <code>Player</code>. With every arrow
we dive a level deeper into the call stack, until we arrive at <code>World</code>. So the
bottom of the call stack in this case is <code>World</code>.</p><h3 id=world-class>World-class<a hidden class=anchor aria-hidden=true href=#world-class>#</a></h3><p>Let&rsquo;s start nice and simple. First, write a test.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> WorldTest {
</span></span><span style=display:flex><span>    @Test
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> `no robots in a new world`() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>val</span> world = World()
</span></span><span style=display:flex><span>        assertThat(world.robotCount).isZero()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Making it pass is easy.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> World {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> robotCount: Int = <span style=color:#ff0;font-weight:700>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For our slice, we need a way to launch a robot into the world.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `launch a robot into the world`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> world = World()
</span></span><span style=display:flex><span>    world.launchRobot()
</span></span><span style=display:flex><span>    assertThat(world.robotCount).isEqualTo(<span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We don&rsquo;t have a <code>launchRobot</code> function yet, so make it compile first.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> World {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> robotCount: Int = <span style=color:#ff0;font-weight:700>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>fun</span> launchRobot() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our test fails, of course: <code>expected:&lt;[1]> but was:&lt;[0]></code>. Let&rsquo;s make it pass.
We&rsquo;ll make the <code>robotCount</code> a <code>var</code> instead of a <code>val</code>, to be able to update
it&rsquo;s value.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> robotCount: Int = <span style=color:#ff0;font-weight:700>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> launchRobot() {
</span></span><span style=display:flex><span>    robotCount++
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now the <code>robotCount</code> property can be updated by everyone. Let&rsquo;s make the setter
private, so only <code>World</code> can update it.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> robotCount: Int = <span style=color:#ff0;font-weight:700>0</span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>set</span>
</span></span></code></pre></div><p>Our tests still pass, so I guess the head of our walking skeleton is done üíÄ. It
doesn&rsquo;t have much of a brain yet, but with the amount of intelligence it
currently has, I&rsquo;d call it &ldquo;undead&rdquo;.</p><h3 id=request-to-launch>Request to launch<a hidden class=anchor aria-hidden=true href=#request-to-launch>#</a></h3><p>Looking at the protocol specification, we can see that every interaction between
client and server is initiated by the client. The communication style is
<a href=https://en.wikipedia.org/wiki/Request%E2%80%93response>request-response</a>. The client
requests the server to execute a command, and the server replies with a result.</p><p>So, if we move one step up the call stack from <code>World::launch</code>, what would we
need? I think it&rsquo;s a function that takes a request and executes the requested
command. Let&rsquo;s implement this without worrying about (de)serializing from/to
JSON yet. We&rsquo;ll start by adding a test to <code>WorldTest</code>.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> `execute a launch command`() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>val</span> world = World()
</span></span><span style=display:flex><span>    world.handleRequest(Request(command = <span style=color:#0ff;font-weight:700>&#34;launch&#34;</span>))
</span></span><span style=display:flex><span>    assertThat(world.robotCount).isEqualTo(<span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This doesn&rsquo;t compile, because we don&rsquo;t have a <code>Request</code> class, and <code>World</code>
doesn&rsquo;t have a <code>handleRequest</code> method. Let&rsquo;s start by letting IntelliJ generate
a <code>Request</code> class for us (I&rsquo;m lazy).</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Request(command: String)
</span></span></code></pre></div><p>Easy. Now, IntelliJ can generate the <code>World::handleRequest</code> method as well.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> handleRequest(request: Request) {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now our test compiles, but it fails: <code>expected:&lt;[1]> but was:&lt;[0]></code>, so let&rsquo;s
make it pass.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#fff;font-weight:700>fun</span> handleRequest(request: Request) {
</span></span><span style=display:flex><span>    launchRobot()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yep, that&rsquo;s all we need for now.</p><h3 id=really>Really?<a hidden class=anchor aria-hidden=true href=#really>#</a></h3><p>Remember the <a href=#walking-skeleton>description from the GOOS book</a> earlier in this
post. Our goal here is not to build an entire feature:</p><blockquote><p>[&mldr;] It should include just enough of the automation, the major components,
and communication mechanisms to allow us to start working on the first
feature.</p></blockquote><p>We just want to get all the stuff in place that we need to build and test our
first feature end-to-end. In a real-world project this would typically include
setting up build scripts, CI/CD, deployment
to <a href=https://en.wikipedia.org/wiki/Development,_testing,_acceptance_and_production>DTAP</a>
environments, etc. By doing this first, we benefit from having all this from the
very start. Immediately, we have everything in place to make sure that every bit
of functionality we add is well-tested, well-factored and potentially shippable.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>We started out by drawing a little architecture diagram to get an overview of
the major parts of the game that we&rsquo;re building. Later on, the sequence diagram
helped us choose a starting point for writing some actual code. I feel like that
was just enough &ldquo;design up front&rdquo; to get me started.</p><p>We got some of the boring project set up stuff out of the way. The project is
set up and a tiny part of a tiny slice of functionality is in place. The <code>World</code>
class will almost certainly be split up into the actual game logic and one or
more other classes which handle requests from the client. We could have chosen
to do that right now, but we can also do it later. I don&rsquo;t think it&rsquo;s really
important right now.</p><p>For now, our goal is to put the major components in place, and <code>World</code> is one of
them. The next steps up the call stack will most likely be the TCP socket
connection and (de)serialization of messages.</p><p>So there it is, 6 months after setting it up, this blog has finally officially
been kicked off. I hope you enjoyed my first post. I certainly enjoyed writing
it. Stay tuned for the next one!</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The container diagram is one of the 4 core diagrams of the
<a href=https://c4model.com>C4 model</a> for visualising software architecture.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.dirkgroot.nl/tags/walking-skeleton/>walking-skeleton</a></li><li><a href=https://blog.dirkgroot.nl/tags/robot-worlds/>robot-worlds</a></li><li><a href=https://blog.dirkgroot.nl/tags/kotlin/>kotlin</a></li><li><a href=https://blog.dirkgroot.nl/tags/tdd/>tdd</a></li></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var t=document,e=t.createElement('script');e.async=!0,e.src='//dirkgroot-github.disqus.com/embed.js',e.setAttribute('data-timestamp',+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.dirkgroot.nl>Dirk Groot</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll('pre > code').forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement('button');e.classList.add('copy-code'),e.innerHTML='copy';function s(){e.innerHTML='copied!',setTimeout(()=>{e.innerHTML='copy'},2e3)}e.addEventListener('click',o=>{if('clipboard'in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand('copy'),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>